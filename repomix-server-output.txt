This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-26T19:39:08.631Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
mud-api/
  src/
    main/
      java/
        com/
          mudgame/
            api/
              commands/
                CommandRegistry.java
                CommandResult.java
                DropCommand.java
                EquipCommand.java
                EquipmentCommand.java
                ExamineCommand.java
                GameCommand.java
                GetCommand.java
                InventoryCommand.java
                LookCommand.java
                MoveCommand.java
                SayCommand.java
                UnequipCommand.java
  pom.xml
mud-entities/
  src/
    main/
      java/
        com/
          mudgame/
            entities/
              enemies/
                EnemyNPC.java
              maps/
                cities/
                  NeoTokyoBuilder.java
                  OldLondonBuilder.java
                BaseMapBuilder.java
                MapBuilder.java
                WorldMapBuilder.java
              npcs/
                SecurityBotNPC.java
              Armor.java
              ArmorType.java
              Attributes.java
              CharacterClass.java
              Consumable.java
              ConsumableType.java
              DamageType.java
              Direction.java
              Equipment.java
              EquipmentSlot.java
              GameMap.java
              Inventory.java
              InventoryItem.java
              InventoryResult.java
              Item.java
              ItemRarity.java
              ItemType.java
              NPC.java
              NPCResponse.java
              NPCState.java
              NPCType.java
              Player.java
              Race.java
              Room.java
              SpawnableNPC.java
              Weapon.java
              WeaponType.java
  pom.xml
mud-server/
  src/
    main/
      java/
        com/
          mudgame/
            server/
              commands/
                DefaultCommandRegistry.java
              config/
                GameConfiguration.java
              core/
                GameManager.java
                GameState.java
              health/
                GameHealthCheck.java
              resources/
                GameResource.java
              services/
                ItemFactory.java
                NPCSpawner.java
                RedisBroadcaster.java
              CORSFilter.java
              GameApplication.java
  dependency-reduced-pom.xml
  pom.xml
shared/
  src/
    main/
      java/
        com/
          mudgame/
            events/
              EventListener.java
            App.java
    test/
      java/
        com/
          mudgame/
            AppTest.java
  pom.xml
.gitignore
config.yml
pom.xml

================================================================
Repository Files
================================================================

================
File: mud-api/src/main/java/com/mudgame/api/commands/CommandRegistry.java
================
package com.mudgame.api.commands;

import java.util.List;
import java.util.Optional;

public interface CommandRegistry {
    void registerCommand(GameCommand command);
    Optional<GameCommand> getCommand(String name);
    List<GameCommand> getAllCommands();

    default String getHelpText() {
        StringBuilder help = new StringBuilder("Available commands:\n");
        getAllCommands().forEach(cmd ->
                help.append(cmd.getHelp()).append("\n")
        );
        return help.toString();
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/CommandResult.java
================
package com.mudgame.api.commands;

public class CommandResult {
    private final boolean success;
    private final String message;
    private final String privateMessage;
    private final String roomMessage;

    private CommandResult(boolean success, String message, String privateMessage, String roomMessage) {
        this.success = success;
        this.message = message;
        this.privateMessage = privateMessage;
        this.roomMessage = roomMessage;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }

    public String getPrivateMessage() {
        return privateMessage;
    }

    public String getRoomMessage() {
        return roomMessage;
    }

    public static CommandResult success(String message) {
        return new CommandResult(true, message, null, null);
    }

    public static CommandResult success(String privateMessage, String roomMessage) {
        return new CommandResult(true, null, privateMessage, roomMessage);
    }

    public static CommandResult failure(String message) {
        return new CommandResult(false, message, null, null);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private boolean success;
        private String message;
        private String privateMessage;
        private String roomMessage;

        public Builder success(boolean success) {
            this.success = success;
            return this;
        }

        public Builder message(String message) {
            this.message = message;
            return this;
        }

        public Builder privateMessage(String privateMessage) {
            this.privateMessage = privateMessage;
            return this;
        }

        public Builder roomMessage(String roomMessage) {
            this.roomMessage = roomMessage;
            return this;
        }

        public CommandResult build() {
            return new CommandResult(success, message, privateMessage, roomMessage);
        }
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/DropCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.InventoryItem;
import com.mudgame.entities.InventoryResult;
import com.mudgame.entities.Player;
import com.mudgame.entities.Room;

import java.util.Optional;

// Command to drop items
public interface DropCommand extends GameCommand {
    @Override
    default String getName() {
        return "drop";
    }

    @Override
    default String getHelp() {
        return "drop <item> [amount] - Drop an item from your inventory";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        if (args.length < 1) {
            return CommandResult.failure("What do you want to drop?");
        }

        Room currentRoom = player.getCurrentRoom();
        if (currentRoom == null) {
            return CommandResult.failure("You are not in any room!");
        }

        String itemName = args[0].toLowerCase();
        int amount = 1;
        if (args.length > 1) {
            try {
                amount = Integer.parseInt(args[1]);
                if (amount < 1) {
                    return CommandResult.failure("Invalid amount specified.");
                }
            } catch (NumberFormatException e) {
                return CommandResult.failure("Invalid amount specified.");
            }
        }

        // Find the item in inventory
        Optional<InventoryItem> inventoryItem = player.getInventory().getItems().stream()
                .filter(item -> item.getItem().getName().toLowerCase().contains(itemName))
                .findFirst();

        if (inventoryItem.isEmpty()) {
            return CommandResult.failure("You don't have that item.");
        }

        // Try to drop the item
        InventoryResult result = player.dropItem(inventoryItem.get().getItem().getId(), amount);
        if (result.isSuccess()) {
            currentRoom.addItem(inventoryItem.get().getItem());
            if (result.isPartial()) {
                return CommandResult.builder()
                        .success(true)
                        .privateMessage("You dropped " + result.getAmount() + " " + inventoryItem.get().getItem().getName())
                        .roomMessage(player.getFullName() + " drops " + inventoryItem.get().getItem().getName())
                        .build();
            } else {
                return CommandResult.builder()
                        .success(true)
                        .privateMessage("You dropped " + inventoryItem.get().getItem().getName())
                        .roomMessage(player.getFullName() + " drops " + inventoryItem.get().getItem().getName())
                        .build();
            }
        }

        return CommandResult.failure(result.getMessage());
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/EquipCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.EquipmentSlot;
import com.mudgame.entities.InventoryItem;
import com.mudgame.entities.InventoryResult;
import com.mudgame.entities.Item;
import com.mudgame.entities.Player;

import java.util.Optional;

// Command to equip items
public interface EquipCommand extends GameCommand {
    @Override
    default String getName() {
        return "equip";
    }

    @Override
    default String getHelp() {
        return "equip <item> - Equip an item from your inventory. Use quotes for items with spaces, e.g. equip \"Recruit's Helmet\"";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        if (args.length < 1) {
            return CommandResult.failure("What do you want to equip?");
        }

        // Join args to handle items with spaces in their names
        String itemName = String.join(" ", args).toLowerCase();

        // Find exact matches first, then partial matches
        Optional<InventoryItem> inventoryItem = player.getInventory().getItems().stream()
                .filter(item -> item.getItem().getName().toLowerCase().equals(itemName))
                .findFirst();

        // If no exact match, try partial match
        if (inventoryItem.isEmpty()) {
            inventoryItem = player.getInventory().getItems().stream()
                    .filter(item -> item.getItem().getName().toLowerCase().contains(itemName))
                    .findFirst();
        }

        if (inventoryItem.isEmpty()) {
            return CommandResult.failure("You don't have that item.");
        }

        Item itemToEquip = inventoryItem.get().getItem();

        if (!itemToEquip.isEquippable()) {
            return CommandResult.failure("That item cannot be equipped.");
        }

        // Check if the slot is already occupied
        EquipmentSlot targetSlot = itemToEquip.getSlot();
        Optional<Item> currentlyEquipped = player.getEquipment().getEquippedItem(targetSlot);

        if (currentlyEquipped.isPresent()) {
            return CommandResult.failure("You already have " + currentlyEquipped.get().getName() +
                    " equipped in the " + targetSlot.toString() + " slot. Unequip it first.");
        }

        // Verify level requirement
        if (itemToEquip.getLevelRequired() > player.getLevel()) {
            return CommandResult.failure("You need to be level " +
                    itemToEquip.getLevelRequired() + " to equip this item.");
        }

        InventoryResult result = player.equipItem(itemToEquip);
        if (result.isSuccess()) {
            return CommandResult.builder()
                    .success(true)
                    .privateMessage("You equipped " + itemToEquip.getName() + " in your " +
                            targetSlot.toString() + " slot.")
                    .roomMessage(player.getFullName() + " equips " + itemToEquip.getName())
                    .build();
        }

        return CommandResult.failure(result.getMessage());
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/EquipmentCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.Player;

// Command to view equipped items
public interface EquipmentCommand extends GameCommand {
    @Override
    default String getName() {
        return "equipment";
    }

    @Override
    default String getHelp() {
        return "equipment - View your equipped items";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        return CommandResult.success(player.getEquipment().getEquipmentDisplay());
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/ExamineCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.EquipmentSlot;
import com.mudgame.entities.InventoryItem;
import com.mudgame.entities.Item;
import com.mudgame.entities.Player;
import com.mudgame.entities.Room;

import java.util.Optional;

// Command to examine items
public interface ExamineCommand extends GameCommand {
    @Override
    default String getName() {
        return "examine";
    }

    @Override
    default String getHelp() {
        return "examine <item> - Get detailed information about an item";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        if (args.length < 1) {
            return CommandResult.failure("What do you want to examine?");
        }

        String itemName = args[0].toLowerCase();

        // Check inventory first
        Optional<InventoryItem> inventoryItem = player.getInventory().getItems().stream()
                .filter(item -> item.getItem().getName().toLowerCase().contains(itemName))
                .findFirst();

        if (inventoryItem.isPresent()) {
            return CommandResult.success(inventoryItem.get().getItem().getDetailedDescription());
        }

        // Check equipped items
        for (EquipmentSlot slot : EquipmentSlot.values()) {
            Optional<Item> equippedItem = player.getEquipment().getEquippedItem(slot);
            if (equippedItem.isPresent() &&
                    equippedItem.get().getName().toLowerCase().contains(itemName)) {
                return CommandResult.success(equippedItem.get().getDetailedDescription());
            }
        }

        // Check room items
        Room currentRoom = player.getCurrentRoom();
        if (currentRoom != null) {
            Optional<Item> roomItem = currentRoom.getItems().stream()
                    .filter(item -> item.getName().toLowerCase().contains(itemName))
                    .findFirst();

            if (roomItem.isPresent()) {
                return CommandResult.success(roomItem.get().getDetailedDescription());
            }
        }

        return CommandResult.failure("You don't see that item anywhere.");
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/GameCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.Player;

public interface GameCommand {
    CommandResult execute(Player player, String[] args);
    String getHelp();
    String getName();
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/GetCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.InventoryResult;
import com.mudgame.entities.Item;
import com.mudgame.entities.Player;
import com.mudgame.entities.Room;

import java.util.Optional;

// Command to pick up items
public interface GetCommand extends GameCommand {
    @Override
    default String getName() {
        return "get";
    }

    @Override
    default String getHelp() {
        return "get <item> [amount] - Pick up an item from the room";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        if (args.length < 1) {
            return CommandResult.failure("What do you want to get?");
        }

        Room currentRoom = player.getCurrentRoom();
        if (currentRoom == null) {
            return CommandResult.failure("You are not in any room!");
        }

        String itemName = args[0].toLowerCase();
        int amount = 1;
        if (args.length > 1) {
            try {
                amount = Integer.parseInt(args[1]);
                if (amount < 1) {
                    return CommandResult.failure("Invalid amount specified.");
                }
            } catch (NumberFormatException e) {
                return CommandResult.failure("Invalid amount specified.");
            }
        }

        // Find the item in the room
        Optional<Item> roomItem = currentRoom.getItems().stream()
                .filter(item -> item.getName().toLowerCase().contains(itemName))
                .findFirst();

        if (roomItem.isEmpty()) {
            return CommandResult.failure("You don't see that here.");
        }

        // Try to add to inventory
        InventoryResult result = player.pickupItem(roomItem.get());
        if (result.isSuccess()) {
            if (result.isPartial()) {
                currentRoom.removeItem(roomItem.get());
                return CommandResult.builder()
                        .success(true)
                        .privateMessage("You picked up " + result.getAmount() + " " + roomItem.get().getName())
                        .roomMessage(player.getFullName() + " picks up " + roomItem.get().getName())
                        .build();
            } else {
                currentRoom.removeItem(roomItem.get());
                return CommandResult.builder()
                        .success(true)
                        .privateMessage("You picked up " + roomItem.get().getName())
                        .roomMessage(player.getFullName() + " picks up " + roomItem.get().getName())
                        .build();
            }
        }

        return CommandResult.failure(result.getMessage());
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/InventoryCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.Player;

// Command to view inventory contents
public interface InventoryCommand extends GameCommand {
    @Override
    default String getName() {
        return "inventory";
    }

    @Override
    default String getHelp() {
        return "inventory - View your inventory contents";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        return CommandResult.success(player.getInventory().getInventoryDisplay());
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/LookCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.Player;
import com.mudgame.entities.Room;

public interface LookCommand extends GameCommand {
    @Override
    default String getName() {
        return "look";
    }

    @Override
    default String getHelp() {
        return "look [target] - Look at your surroundings or a specific target";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        Room currentRoom = player.getCurrentRoom();

        if (currentRoom == null) {
            return CommandResult.failure("You are not in any room!");
        }

        // If no arguments, look at room
        if (args.length == 0) {
            return CommandResult.success(currentRoom.getFullDescription());
        }

        // TODO: Implement looking at specific targets (players, items) when we add inventory system
        return CommandResult.failure("You don't see that here.");
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/MoveCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.Direction;
import com.mudgame.entities.Player;
import com.mudgame.entities.Room;

public interface MoveCommand extends GameCommand {
    @Override
    default String getName() {
        return "move";
    }

    @Override
    default String getHelp() {
        return "move <direction> - Move in the specified direction (n/s/e/w/u/d)";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        if (args.length < 1) {
            return CommandResult.failure("Which direction do you want to move?");
        }

        try {
            Direction direction = Direction.fromCommand(args[0]);
            Room currentRoom = player.getCurrentRoom();

            if (currentRoom == null) {
                return CommandResult.failure("You are not in any room!");
            }

            Room destinationRoom = currentRoom.getExit(direction);
            if (destinationRoom == null) {
                return CommandResult.failure("You cannot go that way.");
            }

            // Remove player from current room
            currentRoom.removePlayer(player);

            // Add player to new room
            destinationRoom.addPlayer(player);

            return CommandResult.builder()
                    .success(true)
                    .privateMessage(destinationRoom.getFullDescription())
                    .roomMessage(player.getFullName() + " has left to the " + direction.name().toLowerCase() + ".")
                    .build();

        } catch (IllegalArgumentException e) {
            return CommandResult.failure("Invalid direction. Use n/s/e/w/u/d.");
        }
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/SayCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.Player;

public interface SayCommand extends GameCommand {
    @Override
    default String getName() {
        return "say";
    }

    @Override
    default String getHelp() {
        return "say <message> - Say something to everyone in the room";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        if (args.length == 0) {
            return CommandResult.failure("What do you want to say?");
        }

        String message = String.join(" ", args);
        return CommandResult.builder()
                .success(true)
                .privateMessage("You say: " + message)
                .roomMessage(player.getFullName() + " says: " + message)
                .build();
    }
}

================
File: mud-api/src/main/java/com/mudgame/api/commands/UnequipCommand.java
================
package com.mudgame.api.commands;

import com.mudgame.entities.EquipmentSlot;
import com.mudgame.entities.InventoryResult;
import com.mudgame.entities.Item;
import com.mudgame.entities.Player;

import java.util.Arrays;
import java.util.Optional;
import java.util.stream.Collectors;

// Command to unequip items
public interface UnequipCommand extends GameCommand {
    @Override
    default String getName() {
        return "unequip";
    }

    @Override
    default String getHelp() {
        return "unequip <slot> - Unequip an item from the specified slot";
    }

    @Override
    default CommandResult execute(Player player, String[] args) {
        if (args.length < 1) {
            return CommandResult.failure("Which slot do you want to unequip from?");
        }

        try {
            EquipmentSlot slot = EquipmentSlot.valueOf(args[0].toUpperCase());
            Optional<Item> equippedItem = player.getEquipment().getEquippedItem(slot);

            if (equippedItem.isEmpty()) {
                return CommandResult.failure("Nothing is equipped in that slot.");
            }

            InventoryResult result = player.unequipItem(slot);
            if (result.isSuccess()) {
                return CommandResult.builder()
                        .success(true)
                        .privateMessage("You unequipped " + equippedItem.get().getName())
                        .roomMessage(player.getFullName() + " unequips " + equippedItem.get().getName())
                        .build();
            }

            return CommandResult.failure(result.getMessage());
        } catch (IllegalArgumentException e) {
            return CommandResult.failure("Invalid equipment slot. Valid slots are: " +
                    String.join(", ", Arrays.stream(EquipmentSlot.values())
                            .map(EquipmentSlot::name)
                            .collect(Collectors.toList())));
        }
    }
}

================
File: mud-api/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.mudgame</groupId>
        <artifactId>mud-game</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>mud-api</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.mudgame</groupId>
            <artifactId>mud-entities</artifactId>
        </dependency>
        <dependency>
            <groupId>io.dropwizard</groupId>
            <artifactId>dropwizard-core</artifactId>
        </dependency>
    </dependencies>
</project>

================
File: mud-entities/src/main/java/com/mudgame/entities/enemies/EnemyNPC.java
================
package com.mudgame.entities.enemies;

import com.mudgame.entities.NPC;
import com.mudgame.entities.NPCState;
import com.mudgame.entities.NPCType;
import com.mudgame.entities.Player;
import com.mudgame.entities.Room;

import java.util.Random;

public class EnemyNPC extends NPC {
    private int attackPower;
    private int attackSpeed; // Ticks between attacks
    private int ticksSinceLastAttack;
    private final Random random = new Random();

    public EnemyNPC(String name, String description, int level,
                    int maxHealth, int attackPower, int attackSpeed) {
        super(name, description, NPCType.ENEMY, level, maxHealth, true);
        this.attackPower = attackPower;
        this.attackSpeed = attackSpeed;
        this.ticksSinceLastAttack = 0;

        // Add some basic hostile responses
        addResponse("hello", "The " + name + " snarls menacingly!");
        addResponse("attack", "The " + name + " prepares to defend itself!");
    }

    @Override
    public void onTick() {
        if (isDead()) return;

        Room room = getCurrentRoom();
        if (room == null) return;

        ticksSinceLastAttack++;

        // If we're hostile and there are players in the room, maybe attack
        if (isHostile() && !room.getPlayers().isEmpty() &&
                ticksSinceLastAttack >= attackSpeed) {

            // Randomly select a player to attack
            Player target = room.getPlayers().stream()
                    .skip(random.nextInt(room.getPlayers().size()))
                    .findFirst()
                    .orElse(null);

            if (target != null) {
                setState(NPCState.HOSTILE);
                attackPlayer(target);
                ticksSinceLastAttack = 0;
            }
        }
    }

    private void attackPlayer(Player player) {
        // Calculate damage (add some randomness)
        int damage = attackPower + random.nextInt(attackPower / 2);
        player.damage(damage);

        // Broadcast message to room
        String message = String.format("%s attacks %s for %d damage!",
                getName(), player.getFullName(), damage);
        // TODO: Add method to broadcast message to room
    }

    @Override
    public String interact(Player player, String action) {
        switch (action.toLowerCase()) {
            case "attack":
                setState(NPCState.HOSTILE);
                return "The " + getName() + " turns to face you, ready to fight!";
            default:
                return getResponse(action);
        }
    }

    @Override
    public void onDeath(Player killer) {
        // Drop loot
        Random random = new Random();
        int credits = 10 + random.nextInt(level * 10);
        killer.setCredits(killer.getCredits() + credits);

        // TODO: Add proper loot tables and drop system
        String message = String.format("%s has been defeated! You gain %d credits.",
                getName(), credits);
        // TODO: Broadcast death message to room
    }

    // Getters and setters for combat stats
    public int getAttackPower() { return attackPower; }
    public void setAttackPower(int attackPower) { this.attackPower = attackPower; }
    public int getAttackSpeed() { return attackSpeed; }
    public void setAttackSpeed(int attackSpeed) { this.attackSpeed = attackSpeed; }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/maps/cities/NeoTokyoBuilder.java
================
package com.mudgame.entities.maps.cities;

import com.mudgame.entities.GameMap;
import com.mudgame.entities.Room;
import com.mudgame.entities.maps.BaseMapBuilder;
import com.mudgame.entities.Direction;

public class NeoTokyoBuilder extends BaseMapBuilder {
    @Override
    public void buildMap(GameMap map) {
        // Main areas
        Room shibuyaCrossing = createAndAddRoom(map,
                "Shibuya Crossing",
                "A massive intersection filled with holographic advertisements and crowds."
        );

        Room securityPost = createAndAddRoom(map,
                "Shibuya Security Post",
                "A reinforced security station overlooking the crossing. Security bots patrol the area."
        );

        Room maintenanceBay = createAndAddRoom(map,
                "Shibuya Maintenance Bay",
                "A cluttered maintenance area filled with spare parts and repair equipment."
        );

        // Connect the rooms
        connectBidirectional(map, shibuyaCrossing, Direction.NORTH, securityPost);
        connectBidirectional(map, securityPost, Direction.EAST, maintenanceBay);

        // Add more rooms and connections as needed
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/maps/cities/OldLondonBuilder.java
================
package com.mudgame.entities.maps.cities;

import com.mudgame.entities.GameMap;
import com.mudgame.entities.Room;
import com.mudgame.entities.maps.BaseMapBuilder;

public class OldLondonBuilder extends BaseMapBuilder {
    @Override
    public void buildMap(GameMap map) {
        // Implementation
        Room bigBen = createAndAddRoom(map,
                "Big Ben Plaza",
                "The ancient clock tower stands tall among modern buildings."
        );

        // Add more rooms and connections
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/maps/BaseMapBuilder.java
================
package com.mudgame.entities.maps;

import com.mudgame.entities.Direction;
import com.mudgame.entities.GameMap;
import com.mudgame.entities.Room;

public abstract class BaseMapBuilder implements MapBuilder {
    protected Room createAndAddRoom(GameMap map, String name, String description) {
        Room room = new Room(name, description);
        map.addRoom(room);
        return room;
    }

    protected void connectBidirectional(GameMap map, Room room1, Direction direction, Room room2) {
        map.connectRooms(room1, direction, room2, true);
    }

    // The buildMap method is left abstract as each specific builder will implement it
    @Override
    public abstract void buildMap(GameMap map);
}

================
File: mud-entities/src/main/java/com/mudgame/entities/maps/MapBuilder.java
================
package com.mudgame.entities.maps;

import com.mudgame.entities.GameMap;

public interface MapBuilder {
    void buildMap(GameMap map);
}

================
File: mud-entities/src/main/java/com/mudgame/entities/maps/WorldMapBuilder.java
================
package com.mudgame.entities.maps;

import com.mudgame.entities.Direction;
import com.mudgame.entities.GameMap;
import com.mudgame.entities.Room;
import com.mudgame.entities.maps.cities.NeoTokyoBuilder;
import com.mudgame.entities.maps.cities.OldLondonBuilder;

import java.util.ArrayList;
import java.util.List;

public class WorldMapBuilder {
    private final List<MapBuilder> builders = new ArrayList<>();

    public WorldMapBuilder() {
        // Register all map builders
        builders.add(new NeoTokyoBuilder());
        builders.add(new OldLondonBuilder());
        // Add more builders as needed
    }

    public GameMap buildWorld() {
        GameMap map = new GameMap();

        // Create central hub/starting area
        Room spaceport = new Room(
                "Central Spaceport",
                "A massive spaceport connecting all major cities and colonies. " +
                        "Ships of all sizes dock and depart regularly."
        );
        map.addRoom(spaceport);
        map.setStartingRoom(spaceport);

        // Build all sub-maps
        for (MapBuilder builder : builders) {
            builder.buildMap(map);
        }

        // Create connections between areas
        createInterAreaConnections(map, spaceport);

        return map;
    }

    private void createInterAreaConnections(GameMap map, Room spaceport) {
        Room neoTokyoEntry = map.getRoomByName("Shibuya Crossing");
        Room oldLondonEntry = map.getRoomByName("Big Ben Plaza");

        map.connectRooms(spaceport, Direction.NORTH, neoTokyoEntry, false);
        map.connectRooms(spaceport, Direction.SOUTH, oldLondonEntry, false);
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/npcs/SecurityBotNPC.java
================
package com.mudgame.entities.npcs;

import com.mudgame.events.EventListener;
import com.mudgame.entities.*;
import com.mudgame.entities.enemies.EnemyNPC;

import java.util.*;

public class SecurityBotNPC extends EnemyNPC implements SpawnableNPC {
    private static final Random random = new Random();
    private static final int MAX_ENERGY = 100;
    private static final double ENERGY_DRAIN_RATE = 1.0; // Energy lost per tick when hostile
    private static final double ENERGY_RECHARGE_RATE = 2.0; // Energy gained per tick when idle

    private int energyLevel;
    private int alertLevel; // 0-3: 0=normal, 1=suspicious, 2=alert, 3=combat
    private long lastScanTime;
    private Set<UUID> knownHostiles;

    private final EventListener eventListener; // Event listener for broadcasting events

    public SecurityBotNPC(int level, EventListener eventListener) {
        super(
                "Security Bot MK-" + (level + random.nextInt(999)),
                generateDescription(level),
                level,
                100 + (level * 20),  // Health scales with level
                10 + (level * 2),    // Attack power scales with level
                3                    // Attacks every 3 ticks
        );

        this.energyLevel = MAX_ENERGY;
        this.alertLevel = 0;
        this.lastScanTime = System.currentTimeMillis();
        this.knownHostiles = new HashSet<>();
        this.eventListener = eventListener; // Save the event listener reference
        initializeResponses();
    }

    private static String generateDescription(int level) {
        StringBuilder desc = new StringBuilder();
        desc.append("A heavily armored security robot with ");

        if (level <= 2) {
            desc.append("basic sensors and lightweight plating. ");
        } else if (level <= 5) {
            desc.append("advanced optical sensors and reinforced plating. ");
        } else {
            desc.append("military-grade targeting systems and heavy combat plating. ");
        }

        desc.append("Its chassis bears the station security insignia and warning symbols. ");
        desc.append("Model designation is clearly visible on its surface.");

        return desc.toString();
    }

    private void initializeResponses() {
        // Basic static responses
        addResponse("hello", "The security bot's sensors focus on you momentarily before emitting a low acknowledgment tone.");
        addResponse("help", "The security bot displays a scrolling message: 'FOR SECURITY ASSISTANCE, REMAIN IN PLACE.'");

        // Dynamic responses using lambdas
        addResponse("status", () -> getStatusResponse());
        addResponse("identify", () -> "Security Unit " + getName() + " - Authorization Level " + getLevel());
        addResponse("diagnostic", () -> getDiagnosticResponse());
        addResponse("systems", () -> getSystemsResponse());
        addResponse("stand down", () -> getStandDownResponse());
        addResponse("threat", () -> getThreatResponse());
    }

    @Override
    public SpawnConfiguration getSpawnConfiguration() {
        return new SpawnConfiguration(
                "security_bot",
                3,
                300,
                Arrays.asList(
                        "Shibuya Crossing",
                        "Shibuya Security Post",
                        ".*Security.*",
                        ".*Maintenance.*",
                        ".*Restricted.*",
                        ".*Cargo Bay.*"
                ),
                1,
                10,
                0.1
        );
    }

    @Override
    public NPC createInstance(int level) {
        return new SecurityBotNPC(level, eventListener);
    }

    @Override
    public void onTick() {
        if (isDead()) return;

        updateEnergy();
        performRoomScan();
        updateAlertStatus();

        if (isHostile()) {
            super.onTick();
        }
    }

    private void updateEnergy() {
        if (isHostile()) {
            energyLevel = Math.max(0, energyLevel - (int) ENERGY_DRAIN_RATE);
            if (energyLevel == 0) {
                setHostile(false);
                setState(NPCState.IDLE);
                alertLevel = 0;
                broadcastToRoom(getName() + " powers down, entering emergency conservation mode.");
            }
        } else if (energyLevel < MAX_ENERGY) {
            energyLevel = Math.min(MAX_ENERGY, energyLevel + (int) ENERGY_RECHARGE_RATE);
            if (energyLevel == MAX_ENERGY && alertLevel > 0) {
                alertLevel = 1; // Return to suspicious state when fully charged
                broadcastToRoom(getName() + " is fully recharged and resumes patrolling.");
            }
        }
    }

    private void performRoomScan() {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastScanTime > 5000) {
            Room room = getCurrentRoom();
            if (room != null) {
                room.getPlayers().forEach(this::assessThreat);
            }
            lastScanTime = currentTime;
        }
    }

    private void assessThreat(Player player) {
        if (knownHostiles.contains(player.getId())) {
            alertLevel = Math.max(alertLevel, 2);
            setHostile(true);
        }
    }

    private void updateAlertStatus() {
        Room room = getCurrentRoom();
        if (room == null) return;

        if (alertLevel > 0 && room.getPlayers().isEmpty()) {
            if (random.nextInt(100) < 10) {
                alertLevel = Math.max(0, alertLevel - 1);
            }
        }
    }

    private void broadcastToRoom(String message) {
        Room room = getCurrentRoom();
        if (room != null) {
            eventListener.onEvent("room", room.getId(), message);
        }
    }

    @Override
    public String interact(Player player, String action) {
        if (isDead()) {
            return "The security bot lies motionless, occasional sparks shooting from its damaged circuits.";
        }

        switch (action.toLowerCase()) {
            case "scan":
                return performScan(player);
            case "hack":
                return attemptHack(player);
            case "deactivate":
                return attemptDeactivate(player);
            case "reboot":
                return attemptReboot(player);
            default:
                return getResponse(action);
        }
    }

    private String performScan(Player player) {
        return String.format(
                "Security Scan Results:\nUnit: %s\nEnergy Level: %d%%\nAlert Status: %s\nThreat Assessment: %s",
                getName(),
                energyLevel,
                getAlertStatusString(),
                knownHostiles.contains(player.getId()) ? "HOSTILE" : "Neutral"
        );
    }

    private String attemptHack(Player player) {
        setHostile(true);
        alertLevel = 3;
        knownHostiles.add(player.getId());
        return "ALERT! Unauthorized access detected! Engaging defense protocols.";
    }

    private String attemptDeactivate(Player player) {
        if (alertLevel > 0) {
            setHostile(true);
            return "ERROR: Cannot deactivate while security protocols are active!";
        }
        return "Access denied. Security authorization required.";
    }

    private String attemptReboot(Player player) {
        if (energyLevel < 20) {
            energyLevel = MAX_ENERGY / 2;
            alertLevel = 0;
            setHostile(false);
            return getName() + " performs an emergency reboot, returning to standby mode.";
        }
        return "ERROR: Reboot only available in low power state.";
    }

    private String getStatusResponse() {
        return String.format("Status Report - %s\nPower: %d%%\nAlert Level: %s\nSystems: %s",
                getName(),
                energyLevel,
                getAlertStatusString(),
                getHealth() > getMaxHealth() * 0.5 ? "Nominal" : "Warning");
    }

    private String getDiagnosticResponse() {
        return String.format("Diagnostic Results:\nModel: Security Bot MK-%d\n" +
                        "Power Systems: %d%%\nCombat Systems: %d%%\nSensor Array: %s\nThreat Level: %s",
                getLevel(),
                energyLevel,
                (getHealth() * 100) / getMaxHealth(),
                alertLevel > 0 ? "ACTIVE" : "Standard",
                getAlertStatusString());
    }

    private String getSystemsResponse() {
        return String.format("Systems Status:\nMain Power: %s\nWeapon Systems: %s\n" +
                        "Defense Grid: %s\nSensor Array: %s",
                energyLevel > 50 ? "ONLINE" : "WARNING",
                isHostile() ? "ENGAGED" : "STANDBY",
                getHealth() > getMaxHealth() * 0.3 ? "ACTIVE" : "CRITICAL",
                alertLevel > 0 ? "ENHANCED" : "NORMAL");
    }

    private String getStandDownResponse() {
        if (alertLevel <= 1) {
            alertLevel = 0;
            setHostile(false);
            return getName() + " acknowledges command, returning to standard patrol mode.";
        }
        return "Unable to comply - threat level too high.";
    }

    private String getThreatResponse() {
        return String.format("Current Threat Assessment:\nAlert Level: %s\n" +
                        "Known Hostiles: %d\nResponse Protocol: %s",
                getAlertStatusString(),
                knownHostiles.size(),
                isHostile() ? "ENGAGE" : "MONITOR");
    }

    private String getAlertStatusString() {
        switch (alertLevel) {
            case 0:
                return "Normal";
            case 1:
                return "Elevated";
            case 2:
                return "High Alert";
            case 3:
                return "Combat Ready";
            default:
                return "Unknown";
        }
    }

    @Override
    public void onDeath(Player killer) {
        super.onDeath(killer);

        int creditDrop = 50 + (getLevel() * 10) + random.nextInt(100);
        killer.setCredits(killer.getCredits() + creditDrop);

        broadcastToRoom(String.format("%s emits a final warning tone before powering down permanently. " +
                "You salvage %d credits worth of parts.", getName(), creditDrop));
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Armor.java
================
package com.mudgame.entities;

import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;

public class Armor extends Item {
    private final int defense;
    private final int energyShield;
    private final ArmorType armorType;
    private final Map<DamageType, Integer> resistances;

    public Armor(String name, String description, ItemRarity rarity,
                 double weight, int value, int levelRequired,
                 int maxDurability, EquipmentSlot slot,
                 int defense, int energyShield, ArmorType armorType,
                 Map<DamageType, Integer> resistances) {
        super(name, description, rarity, ItemType.ARMOR, weight, value,
                levelRequired, maxDurability, slot, false, 1);
        this.defense = defense;
        this.energyShield = energyShield;
        this.armorType = armorType;
        this.resistances = new EnumMap<>(DamageType.class);
        if (resistances != null) {
            this.resistances.putAll(resistances);
        }
    }

    public int getDefense() { return defense; }
    public int getEnergyShield() { return energyShield; }
    public ArmorType getArmorType() { return armorType; }
    public Map<DamageType, Integer> getResistances() {
        return Collections.unmodifiableMap(resistances);
    }

    @Override
    public String getDetailedDescription() {
        StringBuilder sb = new StringBuilder(super.getDetailedDescription());
        sb.append(String.format("Defense: %d\n", defense));
        if (energyShield > 0) {
            sb.append(String.format("Energy Shield: %d\n", energyShield));
        }
        sb.append(String.format("Armor Type: %s\n", armorType));
        if (!resistances.isEmpty()) {
            sb.append("Resistances:\n");
            resistances.forEach((type, value) ->
                    sb.append(String.format("  %s: %d%%\n", type, value)));
        }
        return sb.toString();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/ArmorType.java
================
package com.mudgame.entities;

public enum ArmorType {
    LIGHT,
    MEDIUM,
    HEAVY,
    POWERED
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Attributes.java
================
package com.mudgame.entities;

public enum Attributes {
    STRENGTH,
    INTELLIGENCE,
    SPEED,
    DEXTERITY,
    AGILITY,
    LUCK,
    CHARISMA,
    CONSTITUTION,
    WISDOM,
    PERCEPTION
}

================
File: mud-entities/src/main/java/com/mudgame/entities/CharacterClass.java
================
package com.mudgame.entities;

public enum CharacterClass {
    SOLDIER,
    PILOT,
    HACKER,
    ENGINEER,
    MEDIC
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Consumable.java
================
package com.mudgame.entities;

import static com.mudgame.entities.DamageType.ENERGY;

public class Consumable extends Item {
    private final ConsumableType consumableType;
    private final int effectPower;
    private final int effectDuration;
    private final String effectDescription;
    private int usesRemaining;

    public Consumable(String name, String description, ItemRarity rarity,
                      double weight, int value, int levelRequired,
                      ConsumableType consumableType, int effectPower,
                      int effectDuration, String effectDescription,
                      boolean stackable, int maxStackSize) {
        super(name, description, rarity, ItemType.CONSUMABLE, weight, value,
                levelRequired, 1, null, stackable, maxStackSize);
        this.consumableType = consumableType;
        this.effectPower = effectPower;
        this.effectDuration = effectDuration;
        this.effectDescription = effectDescription;
        this.usesRemaining = 1;
    }

    public ConsumableType getConsumableType() { return consumableType; }
    public int getEffectPower() { return effectPower; }
    public int getEffectDuration() { return effectDuration; }
    public String getEffectDescription() { return effectDescription; }
    public int getUsesRemaining() { return usesRemaining; }

    public boolean use(Player player) {
        if (usesRemaining <= 0) return false;

        // Apply effect based on consumable type
        switch (consumableType) {
            case HEALING:
                player.heal(effectPower);
                break;
            case ENERGY:
                player.restoreEnergy(effectPower);
                break;
            // Add more effect types as needed
        }

        usesRemaining--;
        return true;
    }

    @Override
    public String getDetailedDescription() {
        StringBuilder sb = new StringBuilder(super.getDetailedDescription());
        sb.append(String.format("Type: %s\n", consumableType));
        sb.append(String.format("Effect: %s\n", effectDescription));
        if (effectPower > 0) {
            sb.append(String.format("Power: %d\n", effectPower));
        }
        if (effectDuration > 0) {
            sb.append(String.format("Duration: %d seconds\n", effectDuration));
        }
        return sb.toString();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/ConsumableType.java
================
package com.mudgame.entities;

public enum ConsumableType {
    HEALING,
    ENERGY,
    BUFF,
    ANTIDOTE,
    REPAIR_KIT
}

================
File: mud-entities/src/main/java/com/mudgame/entities/DamageType.java
================
package com.mudgame.entities;

public enum DamageType {
    PHYSICAL,
    ENERGY,
    THERMAL,
    CRYO,
    TOXIC,
    PSI
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Direction.java
================
package com.mudgame.entities;

public enum Direction {
    NORTH("n") {
        @Override
        public Direction opposite() {
            return SOUTH;
        }
    },
    SOUTH("s") {
        @Override
        public Direction opposite() {
            return NORTH;
        }
    },
    EAST("e") {
        @Override
        public Direction opposite() {
            return WEST;
        }
    },
    WEST("w") {
        @Override
        public Direction opposite() {
            return EAST;
        }
    },
    UP("u") {
        @Override
        public Direction opposite() {
            return DOWN;
        }
    },
    DOWN("d") {
        @Override
        public Direction opposite() {
            return UP;
        }
    },
    ENTER("e") {
        @Override
        public Direction opposite() {
            return EXIT;
        }
    },
    EXIT("ex") {
        @Override
        public Direction opposite() {
            return ENTER;
        }
    };

    private final String shortCommand;

    Direction(String shortCommand) {
        this.shortCommand = shortCommand;
    }

    public String getShortCommand() {
        return shortCommand;
    }

    public abstract Direction opposite();

    public static Direction fromCommand(String command) {
        for (Direction direction : values()) {
            if (direction.shortCommand.equalsIgnoreCase(command) ||
                    direction.name().equalsIgnoreCase(command)) {
                return direction;
            }
        }
        throw new IllegalArgumentException("Invalid direction: " + command);
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Equipment.java
================
package com.mudgame.entities;

import java.util.EnumMap;
import java.util.Map;
import java.util.Optional;

public class Equipment {
    private final Map<EquipmentSlot, Item> equipped;
    private Player owner;

    public Equipment(Player owner) {
        this.owner = owner;
        this.equipped = new EnumMap<>(EquipmentSlot.class);
    }

    public Optional<Item> getEquippedItem(EquipmentSlot slot) {
        return Optional.ofNullable(equipped.get(slot));
    }

    public InventoryResult equipItem(Item item) {
        if (!item.isEquippable()) {
            return InventoryResult.failure("This item cannot be equipped");
        }

        if (item.getLevelRequired() > owner.getLevel()) {
            return InventoryResult.failure(
                    "You don't meet the level requirement for this item");
        }

        EquipmentSlot slot = item.getSlot();
        if (equipped.containsKey(slot)) {
            return InventoryResult.failure(
                    "You already have an item equipped in that slot");
        }

        equipped.put(slot, item);
        return InventoryResult.success("Item equipped successfully");
    }

    public InventoryResult unequipItem(EquipmentSlot slot) {
        if (!equipped.containsKey(slot)) {
            return InventoryResult.failure("No item equipped in that slot");
        }

        equipped.remove(slot);
        return InventoryResult.success("Item unequipped successfully");
    }

    public String getEquipmentDisplay() {
        StringBuilder sb = new StringBuilder("Equipment:\n");

        for (EquipmentSlot slot : EquipmentSlot.values()) {
            sb.append(String.format("%s: %s\n",
                    slot.toString(),
                    equipped.containsKey(slot)
                            ? equipped.get(slot).getName()
                            : "Empty"));
        }

        return sb.toString();
    }

    public void setOwner(Player owner) {
        this.owner = owner;
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/EquipmentSlot.java
================
package com.mudgame.entities;

public enum EquipmentSlot {
    HEAD,
    CHEST,
    LEGS,
    FEET,
    HANDS,
    MAIN_HAND,
    OFF_HAND,
    NECK,
    RING_1,
    RING_2,
    BACK
}

================
File: mud-entities/src/main/java/com/mudgame/entities/GameMap.java
================
package com.mudgame.entities;

import com.mudgame.entities.maps.WorldMapBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

public class GameMap {
    private final Map<String, Room> rooms;
    private Room startingRoom;

    public GameMap() {
        this.rooms = new HashMap<>();
    }

    public void addRoom(Room room) {
        rooms.put(room.getId(), room);
        if (startingRoom == null) {
            startingRoom = room;
        }
    }

    public Room getRoom(String id) {
        return rooms.get(id);
    }

    public Room getStartingRoom() {
        return startingRoom;
    }

    public void setStartingRoom(Room room) {
        if (!rooms.containsKey(room.getId())) {
            addRoom(room);
        }
        this.startingRoom = room;
    }

    public void connectRooms(Room room1, Direction direction, Room room2, boolean bidirectional) {
        // Ensure both rooms are in the map
        if (!rooms.containsKey(room1.getId())) {
            addRoom(room1);
        }
        if (!rooms.containsKey(room2.getId())) {
            addRoom(room2);
        }

        // Connect the rooms
        room1.setExit(direction, room2);
        if (bidirectional) {
            room2.setExit(direction.opposite(), room1);
        }
    }

    public Set<Room> getAllRooms() {
        return new HashSet<>(rooms.values());
    }

    // Method to find a path between two rooms (useful for NPCs or automated movement)
    public List<Direction> findPath(Room start, Room destination) {
        if (start == destination) {
            return new ArrayList<>();
        }

        Map<Room, Room> previousRoom = new HashMap<>();
        Map<Room, Direction> previousDirection = new HashMap<>();
        Queue<Room> queue = new LinkedList<>();
        Set<Room> visited = new HashSet<>();

        queue.offer(start);
        visited.add(start);

        while (!queue.isEmpty()) {
            Room current = queue.poll();

            for (Map.Entry<Direction, Room> exit : current.getExits().entrySet()) {
                Room neighbor = exit.getValue();
                Direction direction = exit.getKey();

                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    previousRoom.put(neighbor, current);
                    previousDirection.put(neighbor, direction);
                    queue.offer(neighbor);

                    if (neighbor == destination) {
                        return reconstructPath(previousRoom, previousDirection, start, destination);
                    }
                }
            }
        }

        return null; // No path found
    }

    private List<Direction> reconstructPath(Map<Room, Room> previousRoom,
                                            Map<Room, Direction> previousDirection,
                                            Room start, Room destination) {
        List<Direction> path = new ArrayList<>();
        Room current = destination;

        while (current != start) {
            Room prev = previousRoom.get(current);
            path.add(0, previousDirection.get(current));
            current = prev;
        }

        return path;
    }

    // Factory method to create the game world
    public static GameMap createTestMap() {
        return new WorldMapBuilder().buildWorld();
    }

    // Helper method to get room by name (useful for debugging and testing)
    public Room getRoomByName(String name) {
        return rooms.values().stream()
                .filter(room -> room.getName().equals(name))
                .findFirst()
                .orElse(null);
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Inventory.java
================
package com.mudgame.entities;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;

public class Inventory {
    private final UUID id;
    private final double maxWeight;
    private final int maxSlots;
    private final Map<UUID, InventoryItem> items;
    private double currentWeight;
    private int usedSlots;

    public Inventory(double maxWeight, int maxSlots) {
        this.id = UUID.randomUUID();
        this.maxWeight = maxWeight;
        this.maxSlots = maxSlots;
        this.items = new HashMap<>();
        this.currentWeight = 0;
        this.usedSlots = 0;
    }

    @JsonProperty("maxWeight")
    public double getMaxWeight() { return maxWeight; }

    @JsonProperty("maxSlots")
    public int getMaxSlots() { return maxSlots; }

    @JsonProperty("currentWeight")
    public double getCurrentWeight() { return currentWeight; }

    @JsonProperty("usedSlots")
    public int getUsedSlots() { return usedSlots; }

    @JsonIgnore
    public int getRemainingSlots() { return maxSlots - usedSlots; }

    @JsonIgnore
    public double getRemainingWeight() { return maxWeight - currentWeight; }

    public Collection<InventoryItem> getItems() {
        return Collections.unmodifiableCollection(items.values());
    }

    public Optional<InventoryItem> getItem(UUID itemId) {
        return Optional.ofNullable(items.get(itemId));
    }

    public InventoryResult addItem(Item item) {
        // Check if item can be stacked with existing items
        if (item.isStackable()) {
            Optional<InventoryItem> existingStack = items.values().stream()
                    .filter(invItem -> invItem.canStackWith(item))
                    .findFirst();

            if (existingStack.isPresent()) {
                return addToExistingStack(existingStack.get(), item);
            }
        }

        // If we can't stack, try to add as new item
        return addNewItem(item);
    }

    private InventoryResult addToExistingStack(InventoryItem existingStack, Item item) {
        // Check if adding would exceed weight limit
        double additionalWeight = item.getWeight() * item.getCurrentStackSize();
        if (currentWeight + additionalWeight > maxWeight) {
            return InventoryResult.failure("Adding this item would exceed weight limit");
        }

        // Try to add to stack
        int leftover = existingStack.addToStack(item.getCurrentStackSize());
        currentWeight += item.getWeight() * (item.getCurrentStackSize() - leftover);

        if (leftover > 0) {
            return InventoryResult.partial("Partially added item to existing stack",
                    item.getCurrentStackSize() - leftover);
        }
        return InventoryResult.success("Added item to existing stack");
    }

    private InventoryResult addNewItem(Item item) {
        // Check if we have space
        if (usedSlots >= maxSlots) {
            return InventoryResult.failure("No free inventory slots");
        }

        // Check weight limit
        double itemWeight = item.getTotalWeight();
        if (currentWeight + itemWeight > maxWeight) {
            return InventoryResult.failure("Adding this item would exceed weight limit");
        }

        // Add item
        InventoryItem invItem = new InventoryItem(item);
        items.put(item.getId(), invItem);
        currentWeight += itemWeight;
        usedSlots++;

        return InventoryResult.success("Added item to inventory");
    }

    public InventoryResult removeItem(UUID itemId, int amount) {
        InventoryItem item = items.get(itemId);
        if (item == null) {
            return InventoryResult.failure("Item not found in inventory");
        }

        int removed = item.removeFromStack(amount);
        currentWeight -= item.getItem().getWeight() * removed;

        // If stack is empty, remove the item entirely
        if (item.getCurrentStackSize() <= 0) {
            items.remove(itemId);
            usedSlots--;
        }

        if (removed < amount) {
            return InventoryResult.partial("Partially removed item", removed);
        }
        return InventoryResult.success("Removed item from inventory");
    }

    public String getInventoryDisplay() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("Inventory (%d/%d slots, %.1f/%.1f kg):\n",
                usedSlots, maxSlots, currentWeight, maxWeight));

        if (items.isEmpty()) {
            sb.append("  Empty\n");
        } else {
            // Group items by type
            Map<ItemType, List<InventoryItem>> groupedItems = items.values().stream()
                    .collect(Collectors.groupingBy(item -> item.getItem().getType()));

            groupedItems.forEach((type, itemList) -> {
                sb.append(String.format("\n%s:\n", type));
                itemList.forEach(item ->
                        sb.append(String.format("  %s\n", item.toString()))
                );
            });
        }

        return sb.toString();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/InventoryItem.java
================
package com.mudgame.entities;

public class InventoryItem {
    private final Item item;
    private int currentStackSize;

    public InventoryItem(Item item) {
        this.item = item;
        this.currentStackSize = item.getCurrentStackSize();
    }

    public Item getItem() { return item; }
    public int getCurrentStackSize() { return currentStackSize; }

    public boolean canStackWith(Item other) {
        return item.canStackWith(other);
    }

    public int addToStack(int amount) {
        int maxAddable = item.getMaxStackSize() - currentStackSize;
        int toAdd = Math.min(amount, maxAddable);
        currentStackSize += toAdd;
        return amount - toAdd; // Return leftover amount
    }

    public int removeFromStack(int amount) {
        int toRemove = Math.min(amount, currentStackSize);
        currentStackSize -= toRemove;
        return toRemove;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(item.getName());
        if (item.isStackable() && currentStackSize > 1) {
            sb.append(String.format(" (x%d)", currentStackSize));
        }
        if (item.getDurability() < item.getMaxDurability()) {
            sb.append(String.format(" [%d%%]",
                    (item.getDurability() * 100) / item.getMaxDurability()));
        }
        return sb.toString();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/InventoryResult.java
================
package com.mudgame.entities;

public class InventoryResult {
    private final boolean success;
    private final String message;
    private final int amount;
    private final boolean partial;

    private InventoryResult(boolean success, String message, int amount, boolean partial) {
        this.success = success;
        this.message = message;
        this.amount = amount;
        this.partial = partial;
    }

    public boolean isSuccess() { return success; }
    public String getMessage() { return message; }
    public int getAmount() { return amount; }
    public boolean isPartial() { return partial; }

    public static InventoryResult success(String message) {
        return new InventoryResult(true, message, 0, false);
    }

    public static InventoryResult failure(String message) {
        return new InventoryResult(false, message, 0, false);
    }

    public static InventoryResult partial(String message, int amount) {
        return new InventoryResult(true, message, amount, true);
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Item.java
================
package com.mudgame.entities;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.UUID;

public class Item {
    // Core properties
    private final UUID id;
    private String name;
    private String description;
    private ItemRarity rarity;
    private double weight;
    private int value;
    private int levelRequired;
    private int durability;
    private int maxDurability;
    private ItemType type;
    private EquipmentSlot slot;
    private boolean stackable;
    private int maxStackSize;
    private int currentStackSize;

    // Constructor for new items
    public Item(
            @JsonProperty("name") String name,
            @JsonProperty("description") String description,
            @JsonProperty("rarity") ItemRarity rarity,
            @JsonProperty("type") ItemType type,
            @JsonProperty("weight") double weight,
            @JsonProperty("value") int value,
            @JsonProperty("levelRequired") int levelRequired,
            @JsonProperty("maxDurability") int maxDurability,
            @JsonProperty("slot") EquipmentSlot slot,
            @JsonProperty("stackable") boolean stackable,
            @JsonProperty("maxStackSize") int maxStackSize) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.description = description;
        this.rarity = rarity;
        this.type = type;
        this.weight = weight;
        this.value = value;
        this.levelRequired = levelRequired;
        this.maxDurability = maxDurability;
        this.durability = maxDurability;
        this.slot = slot;
        this.stackable = stackable;
        this.maxStackSize = stackable ? maxStackSize : 1;
        this.currentStackSize = 1;
    }

    // Constructor for loading existing items
    public Item(
            @JsonProperty("id") UUID id,
            @JsonProperty("name") String name,
            @JsonProperty("description") String description,
            @JsonProperty("rarity") ItemRarity rarity,
            @JsonProperty("type") ItemType type,
            @JsonProperty("weight") double weight,
            @JsonProperty("value") int value,
            @JsonProperty("levelRequired") int levelRequired,
            @JsonProperty("durability") int durability,
            @JsonProperty("maxDurability") int maxDurability,
            @JsonProperty("slot") EquipmentSlot slot,
            @JsonProperty("stackable") boolean stackable,
            @JsonProperty("maxStackSize") int maxStackSize,
            @JsonProperty("currentStackSize") int currentStackSize) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.rarity = rarity;
        this.type = type;
        this.weight = weight;
        this.value = value;
        this.levelRequired = levelRequired;
        this.durability = durability;
        this.maxDurability = maxDurability;
        this.slot = slot;
        this.stackable = stackable;
        this.maxStackSize = maxStackSize;
        this.currentStackSize = currentStackSize;
    }

    // Basic getters
    public UUID getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public ItemRarity getRarity() { return rarity; }
    public ItemType getType() { return type; }
    public double getWeight() { return weight; }
    public int getValue() { return value; }
    public int getLevelRequired() { return levelRequired; }
    public int getDurability() { return durability; }
    public int getMaxDurability() { return maxDurability; }
    public EquipmentSlot getSlot() { return slot; }
    public boolean isStackable() { return stackable; }
    public int getMaxStackSize() { return maxStackSize; }
    public int getCurrentStackSize() { return currentStackSize; }

    // Setters for mutable properties
    public void setName(String name) { this.name = name; }
    public void setDescription(String description) { this.description = description; }
    public void setValue(int value) { this.value = value; }
    public void setWeight(double weight) { this.weight = weight; }

    // Stack management
    public boolean canStackWith(Item other) {
        return this.stackable && other.stackable &&
                this.name.equals(other.name) &&
                this.currentStackSize < this.maxStackSize;
    }

    public int addToStack(int amount) {
        int spaceAvailable = maxStackSize - currentStackSize;
        int amountToAdd = Math.min(amount, spaceAvailable);
        currentStackSize += amountToAdd;
        return amount - amountToAdd; // Returns leftover amount
    }

    public int removeFromStack(int amount) {
        int amountToRemove = Math.min(amount, currentStackSize);
        currentStackSize -= amountToRemove;
        return amountToRemove;
    }

    // Durability management
    public void damage(int amount) {
        this.durability = Math.max(0, this.durability - amount);
    }

    public void repair(int amount) {
        this.durability = Math.min(maxDurability, this.durability + amount);
    }

    @JsonIgnore
    public boolean isBroken() {
        return this.durability <= 0;
    }

    // Item state checks
    @JsonIgnore
    public boolean isEquippable() {
        return slot != null;
    }

    @JsonIgnore
    public double getTotalWeight() {
        return weight * currentStackSize;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(name);
        if (stackable && currentStackSize > 1) {
            sb.append(" (x").append(currentStackSize).append(")");
        }
        if (durability < maxDurability) {
            sb.append(" [").append(durability).append("/").append(maxDurability).append("]");
        }
        return sb.toString();
    }

    public String getDetailedDescription() {
        StringBuilder sb = new StringBuilder();
        sb.append(rarity.getColor()).append(name).append("\n");
        sb.append(description).append("\n");
        if (levelRequired > 1) {
            sb.append("Required Level: ").append(levelRequired).append("\n");
        }
        sb.append("Value: ").append(value).append(" credits\n");
        sb.append("Weight: ").append(weight).append(" kg\n");
        if (durability < maxDurability) {
            sb.append("Durability: ").append(durability).append("/").append(maxDurability).append("\n");
        }
        return sb.toString();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/ItemRarity.java
================
package com.mudgame.entities;

// Enums
public enum ItemRarity {
    COMMON("\u001B[37m"),      // White
    UNCOMMON("\u001B[32m"),    // Green
    RARE("\u001B[34m"),        // Blue
    EPIC("\u001B[35m"),        // Purple
    LEGENDARY("\u001B[33m");   // Gold

    private final String colorCode;

    ItemRarity(String colorCode) {
        this.colorCode = colorCode;
    }

    public String getColor() {
        return colorCode;
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/ItemType.java
================
package com.mudgame.entities;

public enum ItemType {
    WEAPON,
    ARMOR,
    CONSUMABLE,
    QUEST,
    MATERIAL,
    CURRENCY,
    CONTAINER
}

================
File: mud-entities/src/main/java/com/mudgame/entities/NPC.java
================
package com.mudgame.entities;

import java.util.*;

public abstract class NPC {
    private final UUID id;
    private String name;
    private String description;
    private NPCType type;
    public int level;
    private int health;
    private int maxHealth;
    private Room currentRoom;
    private boolean isHostile;
    private NPCState state;
    private Inventory inventory;
    private Map<String, NPCResponse> responses = new HashMap<>();

    public NPC(String name, String description, NPCType type, int level, int maxHealth, boolean isHostile) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.description = description;
        this.type = type;
        this.level = level;
        this.maxHealth = maxHealth;
        this.health = maxHealth;
        this.isHostile = isHostile;
        this.state = NPCState.IDLE;
        this.responses = new HashMap<>();
        this.inventory = new Inventory(100.0, 50); // NPCs get larger inventory
    }

    // Core getters
    public UUID getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public NPCType getType() { return type; }
    public int getLevel() { return level; }
    public int getHealth() { return health; }
    public int getMaxHealth() { return maxHealth; }
    public Room getCurrentRoom() { return currentRoom; }
    public boolean isHostile() { return isHostile; }
    public NPCState getState() { return state; }
    public Inventory getInventory() { return inventory; }

    // Core setters
    public void setName(String name) { this.name = name; }
    public void setDescription(String description) { this.description = description; }
    public void setLevel(int level) { this.level = level; }
    public void setHealth(int health) {
        this.health = Math.min(maxHealth, Math.max(0, health));
        if (this.health <= 0) {
            state = NPCState.DEAD;
        }
    }
    public void setMaxHealth(int maxHealth) {
        this.maxHealth = maxHealth;
        if (health > maxHealth) {
            health = maxHealth;
        }
    }
    public void setCurrentRoom(Room room) {
        if (this.currentRoom != null) {
            this.currentRoom.removeNPC(this);
        }
        this.currentRoom = room;
        if (room != null) {
            room.addNPC(this);
        }
    }
    public void setHostile(boolean hostile) { this.isHostile = hostile; }
    public void setState(NPCState state) { this.state = state; }

    // Basic interaction methods
    public String getResponse(String trigger) {
        NPCResponse response = responses.getOrDefault(trigger.toLowerCase(),
                () -> "The " + name + " doesn't seem interested in that.");
        return response.getMessage();
    }

    public void addResponse(String trigger, NPCResponse dynamicResponse) {
        responses.put(trigger.toLowerCase(), dynamicResponse);
    }

    public void addResponse(String trigger, String staticResponse) {
        responses.put(trigger.toLowerCase(), () -> staticResponse);
    }

    // Core gameplay methods
    public void heal(int amount) {
        setHealth(health + amount);
    }

    public void damage(int amount) {
        setHealth(health - amount);
    }

    public boolean isDead() {
        return health <= 0;
    }

    // Abstract methods that specific NPC types must implement
    public abstract void onTick(); // Called each game tick
    public abstract String interact(Player player, String action);
    public abstract void onDeath(Player killer);

    @Override
    public String toString() {
        return String.format("%s [Level %d %s] (%d/%d HP) [%s]",
                name, level, type, health, maxHealth, state);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NPC npc = (NPC) o;
        return id.equals(npc.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/NPCResponse.java
================
package com.mudgame.entities;

@FunctionalInterface
public interface NPCResponse {
    String getMessage();
}

================
File: mud-entities/src/main/java/com/mudgame/entities/NPCState.java
================
package com.mudgame.entities;

public enum NPCState {
    IDLE,       // Default state, not actively doing anything
    HOSTILE,    // Actively hostile/fighting
    BUSY,       // Engaged in some activity (trading, conversation, etc)
    MOVING,     // Moving between locations
    DEAD        // NPC has been killed
}

================
File: mud-entities/src/main/java/com/mudgame/entities/NPCType.java
================
package com.mudgame.entities;

public enum NPCType {
    ENEMY,      // Hostile NPCs that attack players
    MERCHANT,   // NPCs that buy/sell items
    QUEST,      // NPCs that give and manage quests
    AMBIENT     // NPCs that provide atmosphere/immersion
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Player.java
================
package com.mudgame.entities;

import java.util.Optional;
import java.util.UUID;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonIgnore;

public class Player {
    private final UUID id;
    private final UUID ownerId;
    private String firstName;
    private String lastName;
    private Race race;
    private CharacterClass characterClass;
    private int credits;
    private String roomName;  // Changed from currentRoomId
    @JsonIgnore
    private Room currentRoom;
    private int level;
    private int health;
    private int maxHealth;
    private int energy;
    private int maxEnergy;
    private boolean isOnline;
    private long lastSeen;
    private Inventory inventory;
    private Equipment equipment;

    // Constructor for new character creation
    public Player(
            @JsonProperty("ownerId") UUID ownerId,
            @JsonProperty("firstName") String firstName,
            @JsonProperty("lastName") String lastName,
            @JsonProperty("race") Race race,
            @JsonProperty("characterClass") CharacterClass characterClass,
            Inventory inventory,
            Equipment equipment) {
        this.id = UUID.randomUUID();
        this.ownerId = ownerId;
        this.firstName = firstName;
        this.lastName = lastName;
        this.race = race;
        this.characterClass = characterClass;
        this.credits = 100;
        this.level = 1;
        this.health = 100;
        this.maxHealth = 100;
        this.energy = 100;
        this.maxEnergy = 100;
        this.isOnline = false;
        this.lastSeen = System.currentTimeMillis();
        this.inventory = inventory;
        this.equipment = equipment;
    }

    // Constructor for loading existing character
    public Player(
            @JsonProperty("id") UUID id,
            @JsonProperty("ownerId") UUID ownerId,
            @JsonProperty("firstName") String firstName,
            @JsonProperty("lastName") String lastName,
            @JsonProperty("race") Race race,
            @JsonProperty("characterClass") CharacterClass characterClass,
            @JsonProperty("inventory") Inventory inventory,
            @JsonProperty("equipment") Equipment equipment,
            @JsonProperty("credits") int credits,
            @JsonProperty("room_name") String roomName,  // Updated to match DB column
            @JsonProperty("level") int level,
            @JsonProperty("health") int health,
            @JsonProperty("maxHealth") int maxHealth,
            @JsonProperty("energy") int energy,
            @JsonProperty("maxEnergy") int maxEnergy,
            @JsonProperty("lastSeen") long lastSeen) {
        this.id = id;
        this.ownerId = ownerId;
        this.firstName = firstName;
        this.lastName = lastName;
        this.race = race;
        this.characterClass = characterClass;
        this.credits = credits;
        this.roomName = roomName;
        this.level = level;
        this.health = health;
        this.maxHealth = maxHealth;
        this.energy = energy;
        this.maxEnergy = maxEnergy;
        this.isOnline = false;
        this.lastSeen = lastSeen;
        this.inventory = inventory != null ? inventory : new Inventory(100.0, 20);
        this.equipment = equipment != null ? equipment : new Equipment(this);
    }

    // Getters
    public UUID getId() { return id; }
    public UUID getOwnerId() { return ownerId; }
    public String getFirstName() { return firstName; }
    public String getLastName() { return lastName; }
    public String getFullName() { return firstName + (lastName != null ? " " + lastName : ""); }
    public Race getRace() { return race; }
    public CharacterClass getCharacterClass() { return characterClass; }
    public int getCredits() { return credits; }

    @JsonProperty("room_name")  // Match the database column name
    public String getRoomName() { return roomName; }

    @JsonIgnore
    public Room getCurrentRoom() { return currentRoom; }

    public int getLevel() { return level; }
    public int getHealth() { return health; }
    public int getMaxHealth() { return maxHealth; }
    public int getEnergy() { return energy; }
    public int getMaxEnergy() { return maxEnergy; }
    public boolean isOnline() { return isOnline; }
    public long getLastSeen() { return lastSeen; }
    public Inventory getInventory() { return inventory; }
    public Equipment getEquipment() { return equipment; }

    // Setters
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public void setInventory(Inventory inventory) { this.inventory = inventory; }
    public void setEquipment(Equipment equipment) { this.equipment = equipment; }
    public void setCredits(int credits) { this.credits = credits; }

    @JsonProperty("room_name")  // Match the database column name
    public void setRoomName(String roomName) { this.roomName = roomName; }

    public void setCurrentRoom(Room room) {
        this.currentRoom = room;
        if (room != null) {
            this.roomName = room.getName();
        }
    }

    public void setLevel(int level) { this.level = level; }

    public void setHealth(int health) {
        this.health = Math.min(maxHealth, Math.max(0, health));
    }

    public void setMaxHealth(int maxHealth) {
        this.maxHealth = maxHealth;
        if (health > maxHealth) {
            health = maxHealth;
        }
    }

    public void setEnergy(int energy) {
        this.energy = Math.min(maxEnergy, Math.max(0, energy));
    }

    public void setMaxEnergy(int maxEnergy) {
        this.maxEnergy = maxEnergy;
        if (energy > maxEnergy) {
            energy = maxEnergy;
        }
    }

    public void setOnline(boolean online) {
        this.isOnline = online;
        if (!online) {
            this.lastSeen = System.currentTimeMillis();
        }
    }

    // Inventory management methods
    public InventoryResult pickupItem(Item item) {
        return inventory.addItem(item);
    }

    public InventoryResult dropItem(UUID itemId, int amount) {
        return inventory.removeItem(itemId, amount);
    }

    public InventoryResult equipItem(Item item) {
        Optional<InventoryItem> invItem = inventory.getItem(item.getId());
        if (invItem.isEmpty()) {
            return InventoryResult.failure("You don't have that item");
        }

        InventoryResult result = equipment.equipItem(item);
        if (result.isSuccess()) {
            inventory.removeItem(item.getId(), 1);
        }
        return result;
    }

    public InventoryResult unequipItem(EquipmentSlot slot) {
        Optional<Item> equipped = equipment.getEquippedItem(slot);
        if (equipped.isEmpty()) {
            return InventoryResult.failure("Nothing equipped in that slot");
        }

        InventoryResult canAdd = inventory.addItem(equipped.get());
        if (!canAdd.isSuccess()) {
            return InventoryResult.failure("Not enough inventory space to unequip");
        }

        return equipment.unequipItem(slot);
    }

    // Game-related methods
    public void heal(int amount) {
        setHealth(health + amount);
    }

    public void damage(int amount) {
        setHealth(health - amount);
    }

    public void restoreEnergy(int amount) {
        setEnergy(energy + amount);
    }

    public void useEnergy(int amount) {
        setEnergy(energy - amount);
    }

    public boolean isDead() {
        return health <= 0;
    }

    public boolean hasEnoughEnergy(int amount) {
        return energy >= amount;
    }

    @Override
    public String toString() {
        return String.format("%s %s - Level %d %s %s (HP: %d/%d, EP: %d/%d) [%s]",
                firstName, lastName, level, race, characterClass,
                health, maxHealth, energy, maxEnergy,
                isOnline ? "Online" : "Offline");
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Player player = (Player) o;
        return id.equals(player.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Race.java
================
package com.mudgame.entities;

public enum Race {
    HUMAN,
    DRACONIAN,
    SYNTH,
    CONSTRUCT,
    ANDROID
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Room.java
================
package com.mudgame.entities;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

public class Room {
    private final String id;
    private String name;
    private String description;
    private final Map<Direction, Room> exits;
    private final List<Item> items;
    private final Set<Player> players;
    private final Set<NPC> npcs = new HashSet<>();


    public Room(String name, String description) {
        this.id = UUID.randomUUID().toString();
        this.name = name;
        this.description = description;
        this.exits = new EnumMap<>(Direction.class);
        this.items = new ArrayList<>();
        this.players = new HashSet<>();
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setExit(Direction direction, Room room) {
        exits.put(direction, room);
    }

    public Room getExit(Direction direction) {
        return exits.get(direction);
    }

    public Map<Direction, Room> getExits() {
        return Collections.unmodifiableMap(exits);
    }

    public void addItem(Item item) {
        items.add(item);
    }

    public void removeItem(Item item) {
        items.remove(item);
    }

    public List<Item> getItems() {
        return Collections.unmodifiableList(items);
    }

    public void addPlayer(Player player) {
        players.add(player);
        player.setCurrentRoom(this);
    }

    public void removePlayer(Player player) {
        players.remove(player);
        if (player.getCurrentRoom() == this) {
            player.setCurrentRoom(null);
        }
    }

    public Set<Player> getPlayers() {
        return Collections.unmodifiableSet(players);
    }

    public String getFullDescription() {
        StringBuilder sb = new StringBuilder();

        // Room name and description
        sb.append(name).append("\n");
        sb.append(description).append("\n\n");

        // Exits
        if (!exits.isEmpty()) {
            sb.append("Exits: ");
            sb.append(String.join(", ",
                    exits.keySet().stream()
                            .map(dir -> dir.name().toLowerCase())
                            .toArray(String[]::new)));
            sb.append("\n");
        }

        // Items
        if (!items.isEmpty()) {
            sb.append("\nItems here:");
            items.stream()
                    .collect(Collectors.groupingBy(Item::getName, Collectors.counting()))
                    .forEach((name, count) -> {
                        sb.append("\n  ");
                        if (count > 1) {
                            sb.append(name).append(" (x").append(count).append(")");
                        } else {
                            sb.append(name);
                        }
                    });
            sb.append("\n");
        }

        // NPCs
        if (!npcs.isEmpty()) {
            sb.append("\nNPCs here:");
            npcs.forEach(npc -> {
                sb.append("\n  ").append(npc.getName());
                if (npc.isHostile()) {
                    sb.append(" [Hostile]");
                }
                if (npc.getType() == NPCType.MERCHANT) {
                    sb.append(" [Merchant]");
                }
                if (npc.isDead()) {
                    sb.append(" [Dead]");
                }
            });
            sb.append("\n");
        }

        // Players
        if (!players.isEmpty()) {
            sb.append("\nPlayers here:");
            players.forEach(player -> {
                sb.append("\n  ").append(player.getFirstName());
                if (player.isDead()) {
                    sb.append(" [Dead]");
                }
            });
            sb.append("\n");
        }

        return sb.toString();
    }

    public void addNPC(NPC npc) {
        npcs.add(npc);
    }

    public void removeNPC(NPC npc) {
        npcs.remove(npc);
    }

    public Set<NPC> getNPCs() {
        return Collections.unmodifiableSet(npcs);
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/SpawnableNPC.java
================
package com.mudgame.entities;

import java.util.List;

/**
 * Interface for NPCs that defines their spawn behavior.
 * Every NPC type will implement this to control its own spawn logic.
 */
public interface SpawnableNPC {
    /**
     * Get spawn configuration for this NPC type
     */
    SpawnConfiguration getSpawnConfiguration();

    /**
     * Factory method to create a new instance of this NPC
     * @param level The level to spawn the NPC at
     * @return A new instance of the NPC
     */
    NPC createInstance(int level);

    /**
     * Configuration class that encapsulates spawn behavior
     */
    class SpawnConfiguration {
        private final String npcId;
        private final int maxInstances;
        private final int respawnTime;
        private final List<String> validRoomPatterns;
        private final int minLevel;
        private final int maxLevel;
        private final double spawnChance; // Percentage chance to spawn when eligible

        public SpawnConfiguration(
                String npcId,
                int maxInstances,
                int respawnTime,
                List<String> validRoomPatterns,
                int minLevel,
                int maxLevel,
                double spawnChance) {
            this.npcId = npcId;
            this.maxInstances = maxInstances;
            this.respawnTime = respawnTime;
            this.validRoomPatterns = validRoomPatterns;
            this.minLevel = minLevel;
            this.maxLevel = maxLevel;
            this.spawnChance = spawnChance;
        }

        public String getNpcId() { return npcId; }
        public int getMaxInstances() { return maxInstances; }
        public int getRespawnTime() { return respawnTime; }
        public List<String> getValidRoomPatterns() { return validRoomPatterns; }
        public int getMinLevel() { return minLevel; }
        public int getMaxLevel() { return maxLevel; }
        public double getSpawnChance() { return spawnChance; }
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/Weapon.java
================
package com.mudgame.entities;

// Weapon class for weapons
public class Weapon extends Item {
    private final int minDamage;
    private final int maxDamage;
    private final double attackSpeed;
    private final WeaponType weaponType;
    private final DamageType damageType;

    public Weapon(String name, String description, ItemRarity rarity,
                  double weight, int value, int levelRequired,
                  int maxDurability, EquipmentSlot slot,
                  int minDamage, int maxDamage, double attackSpeed,
                  WeaponType weaponType, DamageType damageType) {
        super(name, description, rarity, ItemType.WEAPON, weight, value,
                levelRequired, maxDurability, slot, false, 1);
        this.minDamage = minDamage;
        this.maxDamage = maxDamage;
        this.attackSpeed = attackSpeed;
        this.weaponType = weaponType;
        this.damageType = damageType;
    }

    public int getMinDamage() { return minDamage; }
    public int getMaxDamage() { return maxDamage; }
    public double getAttackSpeed() { return attackSpeed; }
    public WeaponType getWeaponType() { return weaponType; }
    public DamageType getDamageType() { return damageType; }

    @Override
    public String getDetailedDescription() {
        StringBuilder sb = new StringBuilder(super.getDetailedDescription());
        sb.append(String.format("Damage: %d-%d %s\n", minDamage, maxDamage, damageType));
        sb.append(String.format("Attack Speed: %.1f\n", attackSpeed));
        sb.append(String.format("Weapon Type: %s\n", weaponType));
        return sb.toString();
    }
}

================
File: mud-entities/src/main/java/com/mudgame/entities/WeaponType.java
================
package com.mudgame.entities;

public enum WeaponType {
    PISTOL,
    RIFLE,
    SHOTGUN,
    SWORD,
    AXE,
    SPEAR,
    BOW,
    STAFF
}

================
File: mud-entities/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.mudgame</groupId>
        <artifactId>mud-game</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>mud-entities</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.mudgame</groupId>
            <artifactId>shared</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>io.dropwizard</groupId>
            <artifactId>dropwizard-core</artifactId>
        </dependency>
    </dependencies>
</project>

================
File: mud-server/src/main/java/com/mudgame/server/commands/DefaultCommandRegistry.java
================
package com.mudgame.server.commands;


import com.mudgame.api.commands.CommandRegistry;
import com.mudgame.api.commands.CommandResult;
import com.mudgame.api.commands.DropCommand;
import com.mudgame.api.commands.EquipCommand;
import com.mudgame.api.commands.EquipmentCommand;
import com.mudgame.api.commands.ExamineCommand;
import com.mudgame.api.commands.GameCommand;
import com.mudgame.api.commands.GetCommand;
import com.mudgame.api.commands.InventoryCommand;
import com.mudgame.api.commands.LookCommand;
import com.mudgame.api.commands.MoveCommand;
import com.mudgame.api.commands.SayCommand;
import com.mudgame.api.commands.UnequipCommand;
import com.mudgame.entities.Player;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

public class DefaultCommandRegistry implements CommandRegistry {
    private final Map<String, GameCommand> commands;

    public DefaultCommandRegistry() {
        this.commands = new ConcurrentHashMap<>();
        registerDefaultCommands();
    }

    private void registerDefaultCommands() {
        // Register basic movement command
        registerCommand(new MoveCommand() {});

        // Register look command
        registerCommand(new LookCommand() {});

        // Register say command
        registerCommand(new SayCommand() {});

        // Register inventory commands
        registerCommand(new InventoryCommand() {});
        registerCommand(new EquipmentCommand() {});
        registerCommand(new GetCommand() {});
        registerCommand(new DropCommand() {});
        registerCommand(new EquipCommand() {});
        registerCommand(new UnequipCommand() {});
        registerCommand(new ExamineCommand() {});

        // Register help command
        registerCommand(new GameCommand() {
            @Override
            public CommandResult execute(Player player, String[] args) {
                return CommandResult.success(getHelpText());
            }

            @Override
            public String getHelp() {
                return "help - Display this help message";
            }

            @Override
            public String getName() {
                return "help";
            }
        });
    }

    @Override
    public void registerCommand(GameCommand command) {
        commands.put(command.getName().toLowerCase(), command);
    }

    @Override
    public Optional<GameCommand> getCommand(String name) {
        return Optional.ofNullable(commands.get(name.toLowerCase()));
    }

    @Override
    public List<GameCommand> getAllCommands() {
        return new ArrayList<>(commands.values());
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/config/GameConfiguration.java
================
package com.mudgame.server.config;

import io.dropwizard.core.Configuration;
import com.fasterxml.jackson.annotation.JsonProperty;

public class GameConfiguration extends Configuration {
    @JsonProperty
    private String gameName = "Simple MUD";

    @JsonProperty
    private int maxPlayers = 100;

    @JsonProperty
    private boolean debugMode = false;

    @JsonProperty
    private DatabaseConfiguration database;

    public String getGameName() {
        return gameName;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }

    public boolean isDebugMode() {
        return debugMode;
    }

    public DatabaseConfiguration getDatabase() {
        return database;
    }

    public void setGameName(String gameName) {
        this.gameName = gameName;
    }

    public void setMaxPlayers(int maxPlayers) {
        this.maxPlayers = maxPlayers;
    }

    public void setDebugMode(boolean debugMode) {
        this.debugMode = debugMode;
    }

    public void setDatabase(DatabaseConfiguration database) {
        this.database = database;
    }

    public static class DatabaseConfiguration {
        @JsonProperty
        private String url;

        @JsonProperty
        private String password;

        public String getUrl() {
            return url;
        }

        public String getPassword() {
            return password;
        }

        public void setUrl(String url) {
            this.url = url;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/core/GameManager.java
================
package com.mudgame.server.core;

import com.mudgame.events.EventListener;
import com.mudgame.server.services.RedisBroadcaster;
import io.dropwizard.lifecycle.Managed;

import javax.sql.DataSource;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class GameManager implements Managed, EventListener {
    private final RedisBroadcaster redisBroadcaster;
    private final ScheduledExecutorService scheduler;
    private static final int TICK_RATE_MS = 1000; // 1-second tick
    private final GameState gameState;

    public GameManager(int maxPlayers, DataSource dataSource) {
        this.redisBroadcaster = new RedisBroadcaster();
        this.scheduler = Executors.newScheduledThreadPool(1);

        // Pass this instance as the EventListener to GameState
        this.gameState = new GameState(maxPlayers, dataSource, this);

        // Example test event during initialization
        System.out.println("Testing EventListener implementation...");
        onEvent("room", "101", "A test message for room 101.");
        onEvent("player", "202", "A test message for player 202.");
        onEvent("system", null, "A test message for the entire system.");
        System.out.println("EventListener test complete.");
    }

    @Override
    public void onEvent(String eventType, String target, String message) {
        switch (eventType) {
            case "room":
                System.out.println("Broadcasting to room: " + target + " | Message: " + message);
                redisBroadcaster.broadcast("room:" + target, message);
                break;

            case "player":
                System.out.println("Sending private message to player: " + target + " | Message: " + message);
                redisBroadcaster.broadcast("player:" + target, message);
                break;

            case "system":
                System.out.println("Broadcasting system message: " + message);
                redisBroadcaster.broadcast("system", message);
                break;

            default:
                System.err.println("Unknown event type: " + eventType);
        }
    }

    @Override
    public void start() {
        // Schedule the game tick task
        scheduler.scheduleAtFixedRate(() -> {
            try {
                // Perform game state updates
                gameState.tickNPCs();
                System.out.println("Game tick executed.");
            } catch (Exception e) {
                System.err.println("Error in game tick: " + e.getMessage());
                e.printStackTrace();
            }
        }, 0, TICK_RATE_MS, TimeUnit.MILLISECONDS);

        System.out.println("Game manager started with tick rate: " + TICK_RATE_MS + "ms.");
    }

    @Override
    public void stop() {
        // Shutdown the scheduler gracefully
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
        }

        // Clean up Redis resources
        redisBroadcaster.close();
        System.out.println("Game manager stopped.");
    }

    // Expose GameState for external access if needed
    public GameState getGameState() {
        return gameState;
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/core/GameState.java
================
package com.mudgame.server.core;

import com.mudgame.entities.*;
import com.mudgame.server.commands.DefaultCommandRegistry;
import com.mudgame.server.services.ItemFactory;
import com.mudgame.server.services.NPCSpawner;
import com.mudgame.events.EventListener;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class GameState {
    private final GameMap gameMap;
    private final EventListener eventListener;
    private final Map<UUID, Player> players;
    private final int maxPlayers;
    private DefaultCommandRegistry commandRegistry;
    private final ItemFactory itemFactory;
    private final DataSource dataSource;
    private final NPCSpawner npcSpawner;
    private long lastNPCTick = System.currentTimeMillis();
    private static final long NPC_TICK_INTERVAL = 1000; // 1 second tick rate

    public GameState(int maxPlayers, DataSource dataSource, EventListener eventListener) {
        this.maxPlayers = maxPlayers;
        this.players = new ConcurrentHashMap<>();
        this.gameMap = GameMap.createTestMap();
        this.dataSource = dataSource;
        this.eventListener = Objects.requireNonNull(eventListener, "EventListener cannot be null");
        this.itemFactory = new ItemFactory(dataSource);

        // Initialize NPCSpawner with EventListener
        this.npcSpawner = new NPCSpawner(gameMap, eventListener);

        // Spawn initial NPCs
        npcSpawner.spawnInitialNPCs();

        System.out.println("Game world initialized with " + gameMap.getAllRooms().size() + " rooms");
        System.out.println("Starting room: " + gameMap.getStartingRoom().getName());
    }

    // DataSource Getter
    public DataSource getDataSource() {
        return dataSource;
    }

    // NPC Management Methods
    public void tickNPCs() {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastNPCTick >= NPC_TICK_INTERVAL) {
            npcSpawner.getActiveNPCs().forEach(NPC::onTick);
            npcSpawner.handleRespawns();
            lastNPCTick = currentTime;
        }
    }

    public Optional<NPC> getNPC(UUID npcId) {
        return npcSpawner.getNPC(npcId);
    }

    public Collection<NPC> getAllNPCs() {
        return npcSpawner.getActiveNPCs();
    }

    public void removeNPC(UUID npcId) {
        npcSpawner.removeNPC(npcId);
    }

    public NPCSpawner getNpcSpawner() {
        return npcSpawner;
    }

    // Player Management Methods
    public Player getPlayer(UUID playerId) {
        return players.get(playerId);
    }

    public List<Player> getAllPlayers() {
        return new ArrayList<>(players.values());
    }

    public List<Player> getOnlinePlayers() {
        return players.values().stream()
                .filter(Player::isOnline)
                .collect(Collectors.toList());
    }

    public List<Player> getPlayersByOwnerId(UUID ownerId) {
        return players.values().stream()
                .filter(player -> player.getOwnerId().equals(ownerId))
                .collect(Collectors.toList());
    }

    public int getPlayerCount() {
        return players.size();
    }

    public int getOnlinePlayerCount() {
        return (int) players.values().stream()
                .filter(Player::isOnline)
                .count();
    }

    public boolean isPlayerOnline(UUID playerId) {
        Player player = players.get(playerId);
        return player != null && player.isOnline();
    }

    // Character Creation and Management
    public Player createCharacter(UUID id, UUID ownerId, String firstName, String lastName,
                                  Race race, CharacterClass characterClass,
                                  Map<Attributes, Integer> attributes) {
        try {
            Inventory inventory = new Inventory(100.0, 20);
            Equipment equipment = new Equipment(null);

            // Set starting room name
            String startingRoomName = gameMap.getStartingRoom().getName();

            Player newPlayer = new Player(
                    id,
                    ownerId,
                    firstName,
                    lastName,
                    race,
                    characterClass,
                    inventory,
                    equipment,
                    100,
                    startingRoomName,
                    1,
                    100,
                    100,
                    100,
                    100,
                    System.currentTimeMillis()
            );

            players.put(id, newPlayer);

            try {
                itemFactory.giveStarterItems(newPlayer);
            } catch (Exception e) {
                players.remove(id);
                throw e;
            }

            return newPlayer;
        } catch (Exception e) {
            System.err.println("Error creating character: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Error creating character: " + e.getMessage(), e);
        }
    }

    public Player joinGame(UUID userId, UUID playerId) {
        Player player = players.get(playerId);
        if (player == null) {
            throw new IllegalStateException("Character not found");
        }

        if (!player.getOwnerId().equals(userId)) {
            throw new IllegalStateException("Not authorized to use this character");
        }

        System.out.println("Joining game - Player: " + player.getFullName() +
                ", Saved room name: " + player.getRoomName());

        // Get the saved room name
        String roomName = player.getRoomName();
        Room targetRoom = null;

        // Try to find the saved room
        if (roomName != null && !roomName.trim().isEmpty()) {
            targetRoom = gameMap.getRoomByName(roomName);
            System.out.println("Looking for saved room: " + roomName +
                    ", found: " + (targetRoom != null));
        }

        // Only use starting room if no saved room or saved room not found
        if (targetRoom == null) {
            targetRoom = gameMap.getStartingRoom();
            player.setRoomName(targetRoom.getName());
            System.out.println("Using starting room: " + targetRoom.getName());
        }

        // Set the current room and add player to it
        player.setCurrentRoom(targetRoom);
        targetRoom.addPlayer(player);

        // Load inventory and equipment
        player.setInventory(itemFactory.loadPlayerInventory(player));
        player.setEquipment(itemFactory.loadPlayerEquipment(player));
        player.setOnline(true);

        System.out.println("Player " + player.getFirstName() +
                " joined in room: " + targetRoom.getName());
        return player;
    }


    public Player loadPlayer(UUID playerId) {
        Player player = players.get(playerId);
        if (player != null) {
            Room room;

            String roomName = player.getRoomName();
            if (roomName != null) {
                room = gameMap.getRoomByName(roomName);
                if (room == null) {
                    room = gameMap.getStartingRoom();
                    player.setRoomName(room.getName());
                    System.out.println("Room not found: " + roomName + ", placing player in starting room: " + room.getName());
                }
            } else {
                room = gameMap.getStartingRoom();
                player.setRoomName(room.getName());
                System.out.println("No room name found, placing new player in starting room: " + room.getName());
            }

            player.setCurrentRoom(room);
            room.addPlayer(player);

            player.setInventory(itemFactory.loadPlayerInventory(player));
            player.setEquipment(itemFactory.loadPlayerEquipment(player));

            player.setOnline(true);

            System.out.println("Player " + player.getFullName() + " loaded into " + room.getName() +
                    " with " + player.getInventory().getUsedSlots() + " items");
        }
        return player;
    }

    public void unloadPlayer(UUID playerId) {
        Player player = players.get(playerId);
        if (player != null) {
            Room currentRoom = player.getCurrentRoom();
            if (currentRoom != null) {
                currentRoom.removePlayer(player);
            }
            player.setOnline(false);
            savePlayerLocation(player); // Save location before unloading
        }
    }

    public void leaveGame(UUID playerId) {
        unloadPlayer(playerId);
    }


    public void savePlayerLocation(Player player) {
        if (player == null || player.getCurrentRoom() == null) return;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                     "UPDATE character SET room_name = ? WHERE id = ?"
             )) {
            stmt.setString(1, player.getCurrentRoom().getName());
            stmt.setObject(2, player.getId());
            stmt.executeUpdate();
            System.out.println("Saved location for player " + player.getFullName() + ": " + player.getCurrentRoom().getName());
        } catch (SQLException e) {
            System.err.println("Error saving player location: " + e.getMessage());
        }
    }

    // Item Management Methods
    public Optional<Item> getItem(UUID itemId) {
        return itemFactory.getItem(itemId);
    }

    public Collection<Item> getStarterItems() {
        return itemFactory.getStarterItems();
    }

    // Movement and Room Management
    public boolean movePlayer(UUID playerId, Direction direction) {
        Player player = players.get(playerId);
        if (player != null && player.isOnline()) {
            Room currentRoom = player.getCurrentRoom();
            if (currentRoom != null) {
                Room nextRoom = currentRoom.getExit(direction);
                if (nextRoom != null) {
                    currentRoom.removePlayer(player);
                    nextRoom.addPlayer(player);
                    player.setCurrentRoom(nextRoom);

                    savePlayerLocation(player);

                    return true;
                }
            }
        }
        return false;
    }

    public void setCommandRegistry(DefaultCommandRegistry commandRegistry) {
        this.commandRegistry = commandRegistry;
    }

    public DefaultCommandRegistry getCommandRegistry() {
        return commandRegistry;
    }

    // Game State Validation
    public boolean validateGameState() {
        boolean valid = true;

        for (Player player : getOnlinePlayers()) {
            if (player.getCurrentRoom() == null) {
                valid = false;
                Room startingRoom = gameMap.getStartingRoom();
                player.setCurrentRoom(startingRoom);
                startingRoom.addPlayer(player);
            }
        }

        return valid;
    }

    // Cleanup
    public void cleanup() {
        for (Player player : players.values()) {
            if (player.isOnline()) {
                savePlayerLocation(player);
                unloadPlayer(player.getId());
            }
        }

        new ArrayList<>(npcSpawner.getActiveNPCs()).forEach(npc ->
                npcSpawner.removeNPC(npc.getId()));
    }

    public GameMap getGameMap() {
        return gameMap;
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/health/GameHealthCheck.java
================
package com.mudgame.server.health;

import com.codahale.metrics.health.HealthCheck;
import com.mudgame.server.core.GameState;

public class GameHealthCheck extends HealthCheck {
    private final GameState gameState;

    public GameHealthCheck(GameState gameState) {
        this.gameState = gameState;
    }

    @Override
    protected Result check() {
        try {
            int playerCount = gameState.getOnlinePlayerCount();
            int npcCount = gameState.getAllNPCs().size();

            StringBuilder status = new StringBuilder()
                    .append("Game is running with ")
                    .append(playerCount)
                    .append(" players online and ")
                    .append(npcCount)
                    .append(" active NPCs");

            // Perform basic validation
            if (!gameState.validateGameState()) {
                return Result.unhealthy("Game state validation failed");
            }

            return Result.healthy(status.toString());
        } catch (Exception e) {
            return Result.unhealthy("Game state check failed: " + e.getMessage());
        }
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/resources/GameResource.java
================
package com.mudgame.server.resources;

import com.mudgame.api.commands.CommandResult;
import com.mudgame.api.commands.GameCommand;
import com.mudgame.entities.Attributes;
import com.mudgame.entities.CharacterClass;
import com.mudgame.entities.GameMap;
import com.mudgame.entities.Player;
import com.mudgame.entities.Race;
import com.mudgame.entities.Room;
import com.mudgame.server.core.GameState;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.UUID;

@Path("/game")
@Produces(MediaType.APPLICATION_JSON)
public class GameResource {
    private final GameState gameState;
    private final DataSource dataSource;

    public GameResource(GameState gameState) {
        this.gameState = gameState;
        this.dataSource = gameState.getDataSource();
    }

    @GET
    @Path("/characters/{ownerId}")
    public Response getCharacters(@PathParam("ownerId") UUID ownerId) {
        try {
            List<Player> characters = gameState.getPlayersByOwnerId(ownerId);
            return Response.ok(characters).build();
        } catch (Exception e) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(new ErrorResponse(e.getMessage()))
                    .build();
        }
    }

    @POST
    @Path("/characters")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response createCharacter(CreateCharacterRequest request) {
        try {
            // Get room name, use starting room if none provided
            String roomName = request.getCurrentRoomName();
            if (roomName == null) {
                roomName = gameState.getGameMap().getStartingRoom().getName();
            }

            // Create the player with the specified ID
            Player player = gameState.createCharacter(
                    request.getId(),
                    request.getOwnerId(),
                    request.getFirstName(),
                    request.getLastName(),
                    request.getRace(),
                    request.getCharacterClass(),
                    request.getAttributes()
            );

            // Set location using room name
            player.setRoomName(roomName);
            Room room = gameState.getGameMap().getRoomByName(roomName);
            if (room != null) {
                player.setCurrentRoom(room);
                room.addPlayer(player);
            } else {
                // If room not found, use starting room as fallback
                Room startingRoom = gameState.getGameMap().getStartingRoom();
                player.setRoomName(startingRoom.getName());
                player.setCurrentRoom(startingRoom);
                startingRoom.addPlayer(player);
                System.out.println("Room not found: " + roomName + ", placing player in starting room: " + startingRoom.getName());
            }

            return Response.ok(player).build();
        } catch (Exception e) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(new ErrorResponse("Error creating character: " + e.getMessage()))
                    .build();
        }
    }

    @GET
    @Path("/characters/get/{characterId}")
    public Response getCharacter(@PathParam("characterId") UUID characterId) {
        Player player = gameState.getPlayer(characterId);
        if (player != null) {
            return Response.ok(player).build();
        }
        return Response.status(Response.Status.NOT_FOUND)
                .entity(new ErrorResponse("Character not found"))
                .build();
    }

    @POST
    @Path("/attributes/roll")
    public Response rollAttributes() {
        try {
            Map<Attributes, Integer> rolls = new EnumMap<>(Attributes.class);
            Random random = new Random();

            // Roll for each attribute (4d6, drop lowest)
            for (Attributes attr : Attributes.values()) {
                int[] diceRolls = new int[4];
                for (int i = 0; i < 4; i++) {
                    diceRolls[i] = random.nextInt(6) + 1;
                }
                int lowestRoll = Arrays.stream(diceRolls).min().getAsInt();
                int total = Arrays.stream(diceRolls).sum() - lowestRoll;
                rolls.put(attr, total);
            }

            // Validate minimum total
            int totalAttributes = rolls.values().stream().mapToInt(Integer::intValue).sum();
            if (totalAttributes < 65) {  // Minimum total requirement
                return rollAttributes();  // Recursively try again if total is too low
            }

            return Response.ok(new AttributeRollResponse(rolls)).build();
        } catch (Exception e) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(new ErrorResponse(e.getMessage()))
                    .build();
        }
    }

    @POST
    @Path("/join")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response joinGame(JoinRequest request) {
        try {
            System.out.println("Join request received - playerId: " + request.getPlayerId() + ", userId: " + request.getUserId());
            Player player = gameState.joinGame(request.getUserId(), request.getPlayerId());
            if (player == null) {
                System.out.println("Player not found in game state");
                return Response.status(Response.Status.BAD_REQUEST)
                        .entity(new ErrorResponse("Character not found"))
                        .build();
            }

            // Get room name for welcome message
            String locationName = player.getCurrentRoom() != null ?
                    player.getCurrentRoom().getName() :
                    "an unknown location";

            // Create character name based on whether last name exists
            String characterName = player.getLastName() != null && !player.getLastName().trim().isEmpty() ?
                    String.format("%s %s", player.getFirstName(), player.getLastName()) :
                    player.getFirstName();

            // Create a detailed welcome message
            String welcomeMessage = String.format(
                    "Welcome back, %s! You find yourself in %s. " +
                            "[Health: %d/%d | Energy: %d/%d | Credits: %d]",
                    characterName,
                    locationName,
                    player.getHealth(),
                    player.getMaxHealth(),
                    player.getEnergy(),
                    player.getMaxEnergy(),
                    player.getCredits()
            );

            return Response.ok(new JoinResponse(player.getId(), welcomeMessage)).build();
        } catch (IllegalStateException e) {
            System.out.println("Error joining game: " + e.getMessage());
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(new ErrorResponse(e.getMessage()))
                    .build();
        }
    }

    @DELETE
    @Path("/leave/{playerId}")
    public Response leaveGame(@PathParam("playerId") UUID playerId) {
        try {
            gameState.leaveGame(playerId);
            return Response.ok().build();
        } catch (Exception e) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(new ErrorResponse(e.getMessage()))
                    .build();
        }
    }

    @POST
    @Path("/command")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response executeCommand(CommandRequest request) {
        Player player = gameState.getPlayer(request.getPlayerId());
        if (player == null) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity(new ErrorResponse("Player not found"))
                    .build();
        }

        if (!player.isOnline()) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity(new ErrorResponse("Player is not online"))
                    .build();
        }

        String[] parts = request.getCommand().split("\\s+", 2);
        String commandName = parts[0].toLowerCase();
        String[] args = parts.length > 1 ? parts[1].split("\\s+") : new String[0];

        Optional<GameCommand> command = gameState.getCommandRegistry().getCommand(commandName);
        if (command.isEmpty()) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(new ErrorResponse("Unknown command: " + commandName))
                    .build();
        }

        CommandResult result = command.get().execute(player, args);
        return Response.ok(new CommandResponse(result)).build();
    }

    // Request/Response Classes
    public static class CreateCharacterRequest {
        private UUID id;
        private UUID ownerId;
        private String firstName;
        private String lastName;
        private Race race;
        private CharacterClass characterClass;
        private Map<Attributes, Integer> attributes;
        private String currentRoomName;

        // Getters and setters
        public UUID getId() { return id; }
        public void setId(UUID id) { this.id = id; }
        public UUID getOwnerId() { return ownerId; }
        public void setOwnerId(UUID ownerId) { this.ownerId = ownerId; }
        public String getFirstName() { return firstName; }
        public void setFirstName(String firstName) { this.firstName = firstName; }
        public String getLastName() { return lastName; }
        public void setLastName(String lastName) { this.lastName = lastName; }
        public Race getRace() { return race; }
        public void setRace(Race race) { this.race = race; }
        public CharacterClass getCharacterClass() { return characterClass; }
        public void setCharacterClass(CharacterClass characterClass) { this.characterClass = characterClass; }
        public Map<Attributes, Integer> getAttributes() { return attributes; }
        public void setAttributes(Map<Attributes, Integer> attributes) { this.attributes = attributes; }
        public String getCurrentRoomName() { return currentRoomName; }
        public void setCurrentRoomName(String currentRoomName) { this.currentRoomName = currentRoomName; }
    }

    public static class JoinRequest {
        private UUID userId;
        private UUID playerId;

        public UUID getUserId() { return userId; }
        public void setUserId(UUID userId) { this.userId = userId; }
        public UUID getPlayerId() { return playerId; }
        public void setPlayerId(UUID playerId) { this.playerId = playerId; }
    }

    public static class JoinResponse {
        private final UUID playerId;
        private final String message;

        public JoinResponse(UUID playerId, String message) {
            this.playerId = playerId;
            this.message = message;
        }

        public UUID getPlayerId() { return playerId; }
        public String getMessage() { return message; }
    }

    public static class CommandRequest {
        private UUID playerId;
        private String command;

        public UUID getPlayerId() { return playerId; }
        public void setPlayerId(UUID playerId) { this.playerId = playerId; }
        public String getCommand() { return command; }
        public void setCommand(String command) { this.command = command; }
    }

    public static class CommandResponse {
        private final CommandResult result;

        public CommandResponse(CommandResult result) {
            this.result = result;
        }

        public CommandResult getResult() { return result; }
    }

    public static class AttributeRollResponse {
        private final Map<Attributes, Integer> rolls;

        public AttributeRollResponse(Map<Attributes, Integer> rolls) {
            this.rolls = rolls;
        }

        public Map<Attributes, Integer> getRolls() {
            return rolls;
        }
    }

    public static class ErrorResponse {
        private final String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() { return error; }
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/services/ItemFactory.java
================
package com.mudgame.server.services;

import com.mudgame.entities.*;
import java.util.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.concurrent.ConcurrentHashMap;
import javax.sql.DataSource;

public class ItemFactory {
    private final DataSource dataSource;
    private final Map<UUID, Item> itemCache = new ConcurrentHashMap<>();

    public ItemFactory(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    // Main item creation methods
    public Item createFromDatabase(UUID id, Map<String, Object> data) {
        ItemType type = ItemType.valueOf((String) data.get("type"));

        switch (type) {
            case WEAPON:
                return createWeapon(data);
            case ARMOR:
                return createArmor(data);
            case CONSUMABLE:
                return createConsumable(data);
            default:
                return createBaseItem(data);
        }
    }

    private Item createBaseItem(Map<String, Object> data) {
        return new Item(
                (String) data.get("name"),
                (String) data.get("description"),
                ItemRarity.valueOf((String) data.get("rarity")),
                ItemType.valueOf((String) data.get("type")),  // Added ItemType
                ((Number) data.get("weight")).doubleValue(),
                ((Number) data.get("value")).intValue(),
                ((Number) data.get("level_required")).intValue(),
                ((Number) data.get("max_durability")).intValue(),
                data.get("slot") != null ? EquipmentSlot.valueOf((String) data.get("slot")) : null,
                (Boolean) data.get("stackable"),
                ((Number) data.get("max_stack_size")).intValue()
        );
    }

    private Weapon createWeapon(Map<String, Object> data) {
        return new Weapon(
                (String) data.get("name"),
                (String) data.get("description"),
                ItemRarity.valueOf((String) data.get("rarity")),
                ((Number) data.get("weight")).doubleValue(),
                ((Number) data.get("value")).intValue(),
                ((Number) data.get("level_required")).intValue(),
                ((Number) data.get("max_durability")).intValue(),
                EquipmentSlot.valueOf((String) data.get("slot")),
                ((Number) data.get("min_damage")).intValue(),
                ((Number) data.get("max_damage")).intValue(),
                ((Number) data.get("attack_speed")).doubleValue(),
                WeaponType.valueOf((String) data.get("weapon_type")),
                DamageType.valueOf((String) data.get("damage_type"))
        );
    }

    private Armor createArmor(Map<String, Object> data) {
        Map<DamageType, Integer> resistances = new EnumMap<>(DamageType.class);
        resistances.put(DamageType.PHYSICAL, ((Number) data.get("physical_resist")).intValue());
        resistances.put(DamageType.ENERGY, ((Number) data.get("energy_resist")).intValue());
        resistances.put(DamageType.THERMAL, ((Number) data.get("thermal_resist")).intValue());
        resistances.put(DamageType.CRYO, ((Number) data.get("cryo_resist")).intValue());
        resistances.put(DamageType.TOXIC, ((Number) data.get("toxic_resist")).intValue());
        resistances.put(DamageType.PSI, ((Number) data.get("psi_resist")).intValue());

        return new Armor(
                (String) data.get("name"),
                (String) data.get("description"),
                ItemRarity.valueOf((String) data.get("rarity")),
                ((Number) data.get("weight")).doubleValue(),
                ((Number) data.get("value")).intValue(),
                ((Number) data.get("level_required")).intValue(),
                ((Number) data.get("max_durability")).intValue(),
                EquipmentSlot.valueOf((String) data.get("slot")),
                ((Number) data.get("defense")).intValue(),
                ((Number) data.get("energy_shield")).intValue(),
                ArmorType.valueOf((String) data.get("armor_type")),
                resistances
        );
    }

    private Consumable createConsumable(Map<String, Object> data) {
        return new Consumable(
                (String) data.get("name"),
                (String) data.get("description"),
                ItemRarity.valueOf((String) data.get("rarity")),
                ((Number) data.get("weight")).doubleValue(),
                ((Number) data.get("value")).intValue(),
                ((Number) data.get("level_required")).intValue(),
                ConsumableType.valueOf((String) data.get("consumable_type")),
                ((Number) data.get("effect_power")).intValue(),
                ((Number) data.get("effect_duration")).intValue(),
                (String) data.get("effect_description"),
                (Boolean) data.get("stackable"),
                ((Number) data.get("max_stack_size")).intValue()
        );
    }

    // Database interaction methods
    public Collection<Item> getStarterItems() {
        try (Connection conn = dataSource.getConnection()) {
            return executeItemQuery(conn,
                    "SELECT i.*, " +
                            "w.min_damage, w.max_damage, w.attack_speed, w.weapon_type, w.damage_type, " +
                            "a.defense, a.energy_shield, a.armor_type, " +
                            "a.physical_resist, a.energy_resist, a.thermal_resist, " +
                            "a.cryo_resist, a.toxic_resist, a.psi_resist, " +
                            "c.consumable_type, c.effect_power, c.effect_duration, c.effect_description " +
                            "FROM items i " +
                            "LEFT JOIN weapon_properties w ON i.id = w.item_id " +
                            "LEFT JOIN armor_properties a ON i.id = a.item_id " +
                            "LEFT JOIN consumable_properties c ON i.id = c.item_id " +
                            "WHERE i.name LIKE 'Recruit''s%'",
                    null);
        } catch (SQLException e) {
            throw new RuntimeException("Error loading starter items", e);
        }
    }

    public Optional<Item> getItem(UUID itemId) {
        // Check cache first
        Item cachedItem = itemCache.get(itemId);
        if (cachedItem != null) {
            return Optional.of(cachedItem);
        }

        try (Connection conn = dataSource.getConnection()) {
            List<Item> items = executeItemQuery(conn,
                    "SELECT i.*, " +
                            "w.min_damage, w.max_damage, w.attack_speed, w.weapon_type, w.damage_type, " +
                            "a.defense, a.energy_shield, a.armor_type, " +
                            "a.physical_resist, a.energy_resist, a.thermal_resist, " +
                            "a.cryo_resist, a.toxic_resist, a.psi_resist, " +
                            "c.consumable_type, c.effect_power, c.effect_duration, c.effect_description " +
                            "FROM items i " +
                            "LEFT JOIN weapon_properties w ON i.id = w.item_id " +
                            "LEFT JOIN armor_properties a ON i.id = a.item_id " +
                            "LEFT JOIN consumable_properties c ON i.id = c.item_id " +
                            "WHERE i.id = ?",
                    stmt -> stmt.setObject(1, itemId));

            return items.isEmpty() ? Optional.empty() : Optional.of(items.get(0));
        } catch (SQLException e) {
            throw new RuntimeException("Error loading item " + itemId, e);
        }
    }

    public Inventory loadPlayerInventory(Player player) {
        Inventory inventory = new Inventory(100.0, 20); // Default values

        try (Connection conn = dataSource.getConnection()) {
            Collection<Item> items = executeItemQuery(conn,
                    "SELECT i.*, ii.current_durability, ii.current_stack_size, " +
                            "w.min_damage, w.max_damage, w.attack_speed, w.weapon_type, w.damage_type, " +
                            "a.defense, a.energy_shield, a.armor_type, " +
                            "a.physical_resist, a.energy_resist, a.thermal_resist, " +
                            "a.cryo_resist, a.toxic_resist, a.psi_resist, " +
                            "c.consumable_type, c.effect_power, c.effect_duration, c.effect_description " +
                            "FROM inventory_items ii " +
                            "JOIN items i ON ii.item_id = i.id " +
                            "LEFT JOIN weapon_properties w ON i.id = w.item_id " +
                            "LEFT JOIN armor_properties a ON i.id = a.item_id " +
                            "LEFT JOIN consumable_properties c ON i.id = c.item_id " +
                            "WHERE ii.player_id = ? AND ii.equipped = false",
                    stmt -> stmt.setObject(1, player.getId()));

            for (Item item : items) {
                inventory.addItem(item);
            }

            return inventory;
        } catch (SQLException e) {
            throw new RuntimeException("Error loading inventory for player " + player.getId(), e);
        }
    }

    public Equipment loadPlayerEquipment(Player player) {
        Equipment equipment = new Equipment(player);

        try (Connection conn = dataSource.getConnection()) {
            Collection<Item> items = executeItemQuery(conn,
                    "SELECT i.*, ii.current_durability, " +
                            "w.min_damage, w.max_damage, w.attack_speed, w.weapon_type, w.damage_type, " +
                            "a.defense, a.energy_shield, a.armor_type, " +
                            "a.physical_resist, a.energy_resist, a.thermal_resist, " +
                            "a.cryo_resist, a.toxic_resist, a.psi_resist " +
                            "FROM inventory_items ii " +
                            "JOIN items i ON ii.item_id = i.id " +
                            "LEFT JOIN weapon_properties w ON i.id = w.item_id " +
                            "LEFT JOIN armor_properties a ON i.id = a.item_id " +
                            "WHERE ii.player_id = ? AND ii.equipped = true",
                    stmt -> stmt.setObject(1, player.getId()));

            for (Item item : items) {
                equipment.equipItem(item);
            }

            return equipment;
        } catch (SQLException e) {
            throw new RuntimeException("Error loading equipment for player " + player.getId(), e);
        }
    }

    public void giveStarterItems(Player player) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                     "SELECT give_starter_items(?)"
             )) {

            System.out.println("Giving starter items to player: " + player.getId());
            stmt.setObject(1, player.getId());  // Make sure we're using the same ID

            // Log the SQL that would be executed
            System.out.println("Executing SQL with player ID: " + player.getId());

            stmt.execute();

            // Load inventory and equipment
            try {
                Inventory newInventory = loadPlayerInventory(player);
                System.out.println("Loaded inventory with " + newInventory.getUsedSlots() + " items");
                player.setInventory(newInventory);

                Equipment newEquipment = loadPlayerEquipment(player);
                System.out.println("Loaded equipment");
                player.setEquipment(newEquipment);
            } catch (Exception e) {
                System.err.println("Error reloading inventory/equipment: " + e.getMessage());
                e.printStackTrace();
                throw e;
            }
        } catch (SQLException e) {
            System.err.println("Database error in giveStarterItems: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Error giving starter items to player " + player.getId(), e);
        }
    }

    // Helper methods
    private List<Item> executeItemQuery(Connection conn, String sql,
                                        StatementPreparer preparer) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            if (preparer != null) {
                preparer.prepare(stmt);
            }
            ResultSet rs = stmt.executeQuery();
            List<Item> items = new ArrayList<>();

            while (rs.next()) {
                UUID itemId = UUID.fromString(rs.getString("id"));
                Item item = itemCache.computeIfAbsent(itemId,
                        id -> createFromResultSet(rs));
                items.add(item);
            }

            return items;
        }
    }

    private Item createFromResultSet(ResultSet rs) {
        try {
            Map<String, Object> data = new HashMap<>();

            // Map all the base item fields
            data.put("id", UUID.fromString(rs.getString("id")));
            data.put("name", rs.getString("name"));
            data.put("description", rs.getString("description"));
            data.put("rarity", rs.getString("rarity"));
            data.put("type", rs.getString("type"));
            data.put("weight", rs.getDouble("weight"));
            data.put("value", rs.getInt("value"));
            data.put("level_required", rs.getInt("level_required"));
            data.put("max_durability", rs.getInt("max_durability"));
            data.put("slot", rs.getString("slot"));
            data.put("stackable", rs.getBoolean("stackable"));
            data.put("max_stack_size", rs.getInt("max_stack_size"));

            // Map type-specific properties
            String type = rs.getString("type");
            if (type != null) {
                switch (ItemType.valueOf(type)) {
                    case WEAPON:
                        addWeaponProperties(data, rs);
                        break;
                    case ARMOR:
                        addArmorProperties(data, rs);
                        break;
                    case CONSUMABLE:
                        addConsumableProperties(data, rs);
                        break;
                }
            }

            return createFromDatabase((UUID)data.get("id"), data);
        } catch (SQLException e) {
            throw new RuntimeException("Error creating item from ResultSet", e);
        }
    }

    private void addWeaponProperties(Map<String, Object> data, ResultSet rs) throws SQLException {
        data.put("min_damage", rs.getInt("min_damage"));
        data.put("max_damage", rs.getInt("max_damage"));
        data.put("attack_speed", rs.getDouble("attack_speed"));
        data.put("weapon_type", rs.getString("weapon_type"));
        data.put("damage_type", rs.getString("damage_type"));
    }

    private void addArmorProperties(Map<String, Object> data, ResultSet rs) throws SQLException {
        data.put("defense", rs.getInt("defense"));
        data.put("energy_shield", rs.getInt("energy_shield"));
        data.put("armor_type", rs.getString("armor_type"));
        data.put("physical_resist", rs.getInt("physical_resist"));
        data.put("energy_resist", rs.getInt("energy_resist"));
        data.put("thermal_resist", rs.getInt("thermal_resist"));
        data.put("cryo_resist", rs.getInt("cryo_resist"));
        data.put("toxic_resist", rs.getInt("toxic_resist"));
        data.put("psi_resist", rs.getInt("psi_resist"));
    }

    private void addConsumableProperties(Map<String, Object> data, ResultSet rs) throws SQLException {
        data.put("consumable_type", rs.getString("consumable_type"));
        data.put("effect_power", rs.getInt("effect_power"));
        data.put("effect_duration", rs.getInt("effect_duration"));
        data.put("effect_description", rs.getString("effect_description"));
    }

    @FunctionalInterface
    private interface StatementPreparer {
        void prepare(PreparedStatement stmt) throws SQLException;
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/services/NPCSpawner.java
================
package com.mudgame.server.services;

import com.mudgame.entities.*;
import com.mudgame.entities.npcs.*;
import com.mudgame.events.EventListener;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class NPCSpawner {
    private final GameMap gameMap;
    private final EventListener eventListener; // Add EventListener dependency
    private final Map<UUID, NPC> activeNPCs = new ConcurrentHashMap<>();
    private final Map<String, SpawnableNPC> npcTypes = new HashMap<>();
    private final Random random = new Random();

    // Configuration constants
    private static final int SPAWN_CHECK_INTERVAL = 60; // seconds
    private static final double DEFAULT_SPAWN_CHANCE = 0.1; // 10% base chance
    private long lastSpawnCheck = System.currentTimeMillis();

    public NPCSpawner(GameMap gameMap, EventListener eventListener) {
        this.gameMap = gameMap;
        this.eventListener = Objects.requireNonNull(eventListener, "EventListener cannot be null");
        registerNPCTypes();
    }

    /**
     * Register all available NPC types
     */
    private void registerNPCTypes() {
        try {
            // Register security bots
            registerNPCType(new SecurityBotNPC(1, eventListener)); // Pass EventListener to NPCs

            // Additional NPC types will be registered here
            // registerNPCType(new MerchantBotNPC(1, eventListener));
            // registerNPCType(new MaintenanceBotNPC(1, eventListener));

            System.out.println("Registered " + npcTypes.size() + " NPC types");
        } catch (Exception e) {
            System.err.println("Error registering NPC types: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Register a new NPC type with the spawner
     */
    private void registerNPCType(SpawnableNPC npc) {
        SpawnableNPC.SpawnConfiguration config = npc.getSpawnConfiguration();
        if (config == null) {
            throw new IllegalArgumentException("NPC " + npc.getClass().getSimpleName() +
                    " has no spawn configuration");
        }

        npcTypes.put(config.getNpcId(), npc);
        System.out.println("Registered NPC type: " + config.getNpcId());
    }

    /**
     * Spawn initial NPCs when the game world starts
     */
    public void spawnInitialNPCs() {
        System.out.println("Initializing NPC spawns...");

        npcTypes.values().forEach(type -> {
            try {
                SpawnableNPC.SpawnConfiguration config = type.getSpawnConfiguration();
                int count = random.nextInt(config.getMaxInstances() + 1);

                System.out.printf("Spawning %d %s(s)...\n", count, config.getNpcId());

                for (int i = 0; i < count; i++) {
                    int level = generateLevel(config);
                    NPC spawned = spawnNPC(config.getNpcId(), level);
                    if (spawned != null) {
                        System.out.printf("Spawned %s (Level %d) in %s\n",
                                spawned.getName(),
                                spawned.getLevel(),
                                spawned.getCurrentRoom().getName());
                    }
                }
            } catch (Exception e) {
                System.err.println("Error spawning " + type.getSpawnConfiguration().getNpcId() +
                        ": " + e.getMessage());
            }
        });

        System.out.println("Initial NPC spawning complete. Active NPCs: " + activeNPCs.size());
    }

    /**
     * Spawn a specific NPC type at a given level
     */
    public NPC spawnNPC(String npcId, int level) {
        try {
            SpawnableNPC npcType = npcTypes.get(npcId);
            if (npcType == null) {
                System.err.println("Unknown NPC type: " + npcId);
                return null;
            }

            SpawnableNPC.SpawnConfiguration config = npcType.getSpawnConfiguration();

            // Validate level
            if (level < config.getMinLevel() || level > config.getMaxLevel()) {
                System.err.println("Invalid level " + level + " for " + npcId);
                return null;
            }

            // Check instance limits
            long currentCount = countActiveNPCsByType(npcId);
            if (currentCount >= config.getMaxInstances()) {
                return null;
            }

            // Find valid spawn room
            Room spawnRoom = findSpawnRoom(config.getValidRoomPatterns());
            if (spawnRoom == null) {
                System.err.println("No valid spawn room found for " + npcId);
                return null;
            }

            // Create and place NPC
            NPC npc = npcType.createInstance(level);
            npc.setCurrentRoom(spawnRoom);
            activeNPCs.put(npc.getId(), npc);

            System.out.printf("Spawned %s (ID: %s) in %s\n",
                    npc.getName(), npc.getId(), spawnRoom.getName());
            return npc;

        } catch (Exception e) {
            System.err.println("Error spawning NPC: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Find a suitable room for spawning an NPC
     */
    private Room findSpawnRoom(List<String> validRoomPatterns) {
        List<Room> validRooms = new ArrayList<>();

        for (Room room : gameMap.getAllRooms()) {
            for (String pattern : validRoomPatterns) {
                if (room.getName().matches(pattern)) {
                    validRooms.add(room);
                    break;
                }
            }
        }

        if (validRooms.isEmpty()) return null;

        // First try to find a room without other NPCs
        List<Room> emptyRooms = validRooms.stream()
                .filter(room -> room.getNPCs().isEmpty())
                .collect(Collectors.toList());

        if (!emptyRooms.isEmpty()) {
            return emptyRooms.get(random.nextInt(emptyRooms.size()));
        }

        // If all rooms have NPCs, just pick a random one
        return validRooms.get(random.nextInt(validRooms.size()));
    }

    /**
     * Remove an NPC from the game
     */
    public void removeNPC(UUID npcId) {
        NPC npc = activeNPCs.remove(npcId);
        if (npc != null) {
            if (npc.getCurrentRoom() != null) {
                npc.getCurrentRoom().removeNPC(npc);
            }
            System.out.println("Removed NPC: " + npc.getName() + " (ID: " + npcId + ")");
        }
    }

    /**
     * Handle NPC respawning
     */
    public void handleRespawns() {
        long currentTime = System.currentTimeMillis();
        if ((currentTime - lastSpawnCheck) / 1000 < SPAWN_CHECK_INTERVAL) {
            return; // Not time to check spawns yet
        }

        lastSpawnCheck = currentTime;

        npcTypes.values().forEach(type -> {
            try {
                SpawnableNPC.SpawnConfiguration config = type.getSpawnConfiguration();
                long currentCount = countActiveNPCsByType(config.getNpcId());

                if (currentCount < config.getMaxInstances() &&
                        random.nextDouble() < config.getSpawnChance()) {

                    int level = generateLevel(config);
                    NPC spawned = spawnNPC(config.getNpcId(), level);

                    if (spawned != null) {
                        System.out.printf("Respawned %s (Level %d) in %s\n",
                                spawned.getName(),
                                spawned.getLevel(),
                                spawned.getCurrentRoom().getName());
                    }
                }
            } catch (Exception e) {
                System.err.println("Error handling respawn for " +
                        type.getSpawnConfiguration().getNpcId() + ": " + e.getMessage());
            }
        });
    }

    /**
     * Generate a level for a new NPC based on its configuration
     */
    private int generateLevel(SpawnableNPC.SpawnConfiguration config) {
        return random.nextInt(config.getMaxLevel() - config.getMinLevel() + 1)
                + config.getMinLevel();
    }

    /**
     * Count active NPCs of a specific type
     */
    private long countActiveNPCsByType(String npcId) {
        return activeNPCs.values().stream()
                .filter(npc -> npc.getName().startsWith(npcId))
                .count();
    }

    /**
     * Get all active NPCs
     */
    public Collection<NPC> getActiveNPCs() {
        return Collections.unmodifiableCollection(activeNPCs.values());
    }

    /**
     * Get a specific NPC by ID
     */
    public Optional<NPC> getNPC(UUID id) {
        return Optional.ofNullable(activeNPCs.get(id));
    }

    /**
     * Get all NPCs of a specific type
     */
    public List<NPC> getNPCsByType(String npcId) {
        return activeNPCs.values().stream()
                .filter(npc -> npc.getName().startsWith(npcId))
                .collect(Collectors.toList());
    }

    /**
     * Clear all NPCs (useful for shutdown/reset)
     */
    public void clearAllNPCs() {
        List<UUID> npcIds = new ArrayList<>(activeNPCs.keySet());
        npcIds.forEach(this::removeNPC);
        System.out.println("Cleared all NPCs");
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/services/RedisBroadcaster.java
================
package com.mudgame.server.services;

import redis.clients.jedis.Jedis;

public class RedisBroadcaster {
    private final Jedis redis;

    public RedisBroadcaster() {
        // Connect to Redis at localhost on default port 6379
        this.redis = new Jedis("localhost", 6379);
    }

    /**
     * Publishes a message to a specified Redis channel.
     *
     * @param channel The Redis channel to publish the message to.
     * @param message The message to broadcast.
     */
    public void broadcast(String channel, String message) {
        try {
            redis.publish(channel, message);
            System.out.println("Message broadcasted to channel [" + channel + "]: " + message);
        } catch (Exception e) {
            System.err.println("Error broadcasting message: " + e.getMessage());
        }
    }

    /**
     * Closes the Redis connection.
     */
    public void close() {
        redis.close();
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/CORSFilter.java
================
package com.mudgame.server;

import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerResponseContext;
import jakarta.ws.rs.container.ContainerResponseFilter;
import jakarta.ws.rs.ext.Provider;

@Provider
public class CORSFilter implements ContainerResponseFilter {
    @Override
    public void filter(ContainerRequestContext request,
                       ContainerResponseContext response) {
        response.getHeaders().add("Access-Control-Allow-Origin", "*");
        response.getHeaders().add("Access-Control-Allow-Headers",
                "origin, content-type, accept, authorization");
        response.getHeaders().add("Access-Control-Allow-Credentials", "true");
        response.getHeaders().add("Access-Control-Allow-Methods",
                "GET, POST, PUT, DELETE, OPTIONS, HEAD");
    }
}

================
File: mud-server/src/main/java/com/mudgame/server/GameApplication.java
================
package com.mudgame.server;

import com.mudgame.server.config.GameConfiguration;
import com.mudgame.server.core.GameState;
import com.mudgame.server.core.GameManager;
import com.mudgame.server.health.GameHealthCheck;
import com.mudgame.server.resources.GameResource;
import com.mudgame.server.commands.DefaultCommandRegistry;
import io.dropwizard.core.Application;
import io.dropwizard.core.setup.Environment;
import org.postgresql.ds.PGSimpleDataSource;

public class GameApplication extends Application<GameConfiguration> {
    public static void main(String[] args) throws Exception {
        new GameApplication().run(args);
    }

    @Override
    public void run(GameConfiguration configuration, Environment environment) {
        // Create DataSource for Supabase
        PGSimpleDataSource dataSource = new PGSimpleDataSource();

        // Format: jdbc:postgresql://[host]:[port]/[database]
        String jdbcUrl = "jdbc:postgresql://" +
                "db.yilcjyoumyesbfqbjgpd.supabase.co:5432" +
                "/postgres";

        dataSource.setURL(jdbcUrl);
        dataSource.setUser("postgres");
        dataSource.setPassword(configuration.getDatabase().getPassword());

        // Set additional properties
        dataSource.setSsl(true);
        dataSource.setSslMode("require");

        // Create and register the GameManager (which initializes GameState and EventListener)
        GameManager gameManager = new GameManager(configuration.getMaxPlayers(), dataSource);
        environment.lifecycle().manage(gameManager);

        // Get GameState from GameManager
        GameState gameState = gameManager.getGameState();

        // Register commands
        DefaultCommandRegistry commandRegistry = new DefaultCommandRegistry();
        gameState.setCommandRegistry(commandRegistry);

        // Register health check
        GameHealthCheck healthCheck = new GameHealthCheck(gameState);
        environment.healthChecks().register("game", healthCheck);

        // Register resources
        GameResource gameResource = new GameResource(gameState);
        environment.jersey().register(gameResource);

        // Enable CORS
        environment.jersey().register(new CORSFilter());
    }
}

================
File: mud-server/dependency-reduced-pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <parent>
    <artifactId>mud-game</artifactId>
    <groupId>com.mudgame</groupId>
    <version>1.0-SNAPSHOT</version>
  </parent>
  <modelVersion>4.0.0</modelVersion>
  <artifactId>mud-server</artifactId>
  <build>
    <plugins>
      <plugin>
        <artifactId>maven-shade-plugin</artifactId>
        <version>3.2.4</version>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>shade</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <createDependencyReducedPom>true</createDependencyReducedPom>
          <transformers>
            <transformer />
            <transformer>
              <mainClass>com.mudgame.server.GameApplication</mainClass>
            </transformer>
          </transformers>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>

================
File: mud-server/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.mudgame</groupId>
        <artifactId>mud-game</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>mud-server</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.mudgame</groupId>
            <artifactId>mud-api</artifactId>
        </dependency>
        <dependency>
            <groupId>com.mudgame</groupId>
            <artifactId>mud-entities</artifactId>
        </dependency>
        <dependency>
            <groupId>io.dropwizard</groupId>
            <artifactId>dropwizard-core</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.ws.rs</groupId>
            <artifactId>jakarta.ws.rs-api</artifactId>
            <version>3.1.0</version>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
        </dependency>
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
            <version>4.3.1</version>
        </dependency>
        <dependency>
            <groupId>com.mudgame</groupId>
            <artifactId>shared</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.2.4</version>
                <configuration>
                    <createDependencyReducedPom>true</createDependencyReducedPom>
                    <transformers>
                        <transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/>
                        <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                            <mainClass>com.mudgame.server.GameApplication</mainClass>
                        </transformer>
                    </transformers>
                </configuration>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

================
File: shared/src/main/java/com/mudgame/events/EventListener.java
================
package com.mudgame.events;

/**
 * Interface for handling game events.
 */
public interface EventListener {
    /**
     * Handles an event.
     *
     * @param eventType The type of the event (e.g., "room", "player", "system").
     * @param target    The target of the event (e.g., room ID, player ID).
     * @param message   The message to process.
     */
    void onEvent(String eventType, String target, String message);
}

================
File: shared/src/main/java/com/mudgame/App.java
================
package com.mudgame;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
}

================
File: shared/src/test/java/com/mudgame/AppTest.java
================
package com.mudgame;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

/**
 * Unit test for simple App.
 */
public class AppTest 
    extends TestCase
{
    /**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }

    /**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }

    /**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
}

================
File: shared/pom.xml
================
<?xml version="1.0"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.mudgame</groupId>
    <artifactId>mud-game</artifactId>
    <version>1.0-SNAPSHOT</version>
  </parent>
  <groupId>com.mudgame</groupId>
  <artifactId>shared</artifactId>
  <version>1.0-SNAPSHOT</version>
  <name>shared</name>
  <url>http://maven.apache.org</url>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>

================
File: .gitignore
================
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### IntelliJ IDEA ###
.idea/modules.xml
.idea/jarRepositories.xml
.idea/compiler.xml
.idea/libraries/
*.iws
*.iml
*.ipr

### Eclipse ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Mac OS ###
.DS_Store

================
File: config.yml
================
gameName: JMUD
maxPlayers: 10000
debugMode: true

database:
  password: "ns+yki96n69s"  # Your database password

server:
  applicationConnectors:
    - type: http
      port: 1030
  adminConnectors:
    - type: http
      port: 1031

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mudgame</groupId>
  <artifactId>mud-game</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  <modules>
    <module>mud-api</module>
    <module>mud-entities</module>
    <module>mud-server</module>
    <module>shared</module>
  </modules>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>11</maven.compiler.source>
    <maven.compiler.target>11</maven.compiler.target>
    <dropwizard.version>4.0.1</dropwizard.version>
    <jackson.version>2.15.3</jackson.version>
  </properties>
  <dependencyManagement>
    <dependencies>
      <!-- Dropwizard BOM -->
      <dependency>
        <groupId>io.dropwizard</groupId>
        <artifactId>dropwizard-bom</artifactId>
        <version>${dropwizard.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <!-- Dropwizard Core -->
      <dependency>
        <groupId>io.dropwizard</groupId>
        <artifactId>dropwizard-core</artifactId>
        <version>${dropwizard.version}</version>
      </dependency>
      <!-- Jackson Dependencies -->
      <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-core</artifactId>
        <version>${jackson.version}</version>
      </dependency>
      <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>${jackson.version}</version>
      </dependency>
      <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-annotations</artifactId>
        <version>${jackson.version}</version>
      </dependency>
      <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.6.0</version>
      </dependency>
      <!-- Project Dependencies -->
      <dependency>
        <groupId>com.mudgame</groupId>
        <artifactId>mud-api</artifactId>
        <version>${project.version}</version>
      </dependency>
      <dependency>
        <groupId>com.mudgame</groupId>
        <artifactId>mud-entities</artifactId>
        <version>${project.version}</version>
      </dependency>
    </dependencies>
  </dependencyManagement>
  <build>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.11.0</version>
        </plugin>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-shade-plugin</artifactId>
          <version>3.5.1</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>
